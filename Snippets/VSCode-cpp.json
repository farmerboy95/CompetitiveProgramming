{
    "CP Starter": {
        "prefix": "zzCPStarter",
        "body": [
            "/*",
            "    Author: Nguyen Tan Bao",
            "    Status:",
            "    Idea:",
            "*/",
            "",
            "#include <bits/stdc++.h>",
            "#define FI first",
            "#define SE second",
            "#define EPS 1e-9",
            "#define ALL(a) a.begin(),a.end()",
            "#define SZ(a) int((a).size())",
            "#define MS(s, n) memset(s, n, sizeof(s))",
            "#define FOR(i,a,b) for (int i = (a); i <= (b); i++)",
            "#define FORE(i,a,b) for (int i = (a); i >= (b); i--)",
            "#define FORALL(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)",
            "//__builtin_ffs(x) return 1 + index of least significant 1-bit of x",
            "//__builtin_clz(x) return number of leading zeros of x",
            "//__builtin_ctz(x) return number of trailing zeros of x",
            "",
            "using namespace std;",
            "using ll = long long;",
            "using ld = double;",
            "typedef pair<int, int> II;",
            "typedef pair<II, int> III;",
            "typedef complex<ld> cd;",
            "typedef vector<cd> vcd;",
            "",
            "const ll MODBASE = 1000000007LL;",
            "const int MAXN = 110;",
            "const int MAXM = 1000;",
            "const int MAXK = 16;",
            "const int MAXQ = 200010;",
            "",
            "int main() {",
            "    ios::sync_with_stdio(0);",
            "    cin.tie(nullptr);",
            "    return 0;",
            "}",
            ""
        ],
        "description": "CP Starter"
    },
    "GCD Function": {
        "prefix": "zzGCDFunction",
        "body": [
            "int gcd(int a, int b) {",
            "    while (b) {",
            "        a %= b;",
            "        swap(a, b);",
            "    }",
            "    return a;",
            "}"
        ],
        "description": "GCD Function"
    },
    "Sieve of Eratosthenes": {
        "prefix": "zzSieveBase",
        "body": [
            "void sieveBase(int n) {",
            "    FOR(i,2,n) {",
            "        if (nt[i] == 0) {",
            "            nt[i] = i;",
            "            for (ll j = (ll) i * i; j <= n; j += i) nt[j] = i;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Sieve of Eratosthenes"
    },
    "Binary Exponentiation": {
        "prefix": "zzBinPowMod",
        "body": [
          "ll binPowMod(ll a, ll b) {",
          "    a %= MOD;",
          "    ll res = 1;",
          "    while (b > 0) {",
          "        if (b & 1LL) res = res * a % MOD;",
          "        a = a * a % MOD;",
          "        b >>= 1LL;",
          "    }",
          "    return res;",
          "}",
          "",
          "ll add(ll a, ll b) {",
          "    return (a + b) % MOD;",
          "}",
          "",
          "ll sub(ll a, ll b) {",
          "    return (a - b + MOD) % MOD;",
          "}",
          "",
          "ll mul(ll a, ll b) {",
          "    return a * b % MOD;",
          "}"
        ],
        "description": "Binary Exponentiation"
    },
    "Extended Euclid Algorithm": {
        "prefix": "zzExtendedEuclid",
        "body": [
            "int extendedEuclid(int a, int b, int &x, int &y) {",
            "    if (b == 0) {",
            "        x = 1;",
            "        y = 0;",
            "        return a;",
            "    }",
            "    int X1, Y1;",
            "    int d = extendedEuclid(b, a % b, X1, Y1);",
            "    x = Y1;",
            "    y = X1 - Y1 * (a / b);",
            "    return d;",
            "}"
        ],
        "description": "Extended Euclid Algorithm"
    },
    "Disjoint Set Union": {
        "prefix": "zzDSU",
        "body": [
            "struct DisjointSetUnion {",
            "  public:",
            "    // creates an undirected graph with n vertices and 0 edges.",
            "    DisjointSetUnion() : _n(0) {}",
            "    DisjointSetUnion(int n) : _n(n), parent_or_size(n, -1) {}",
            "",
            "    // add an edge (u, v)",
            "    // If the vertices u and v were in the same connected component, ",
            "    // it returns the representative of this connected component. ",
            "    // Otherwise, it returns the representative of the new connected component.",
            "    int merge(int u, int v) {",
            "        assert(0 <= u && u < _n);",
            "        assert(0 <= v && v < _n);",
            "        int x = leader(u), y = leader(v);",
            "        if (x == y) return x;",
            "        if (-parent_or_size[x] < -parent_or_size[y]) swap(x, y);",
            "        parent_or_size[x] += parent_or_size[y];",
            "        parent_or_size[y] = x;",
            "        return x;",
            "    }",
            "",
            "    // It returns whether the vertices u and v are in the same connected component",
            "    bool same(int u, int v) {",
            "        assert(0 <= u && u < _n);",
            "        assert(0 <= v && v < _n);",
            "        return leader(u) == leader(v);",
            "    }",
            "",
            "    // It returns the representative of the connected component that contains the vertex u",
            "    int leader(int u) {",
            "        assert(0 <= u && u < _n);",
            "        if (parent_or_size[u] < 0) return u;",
            "        return parent_or_size[u] = leader(parent_or_size[u]);",
            "    }",
            "",
            "    // It returns the size of the connected component that contains the vertex u",
            "    int size(int u) {",
            "        assert(0 <= u && u < _n);",
            "        return -parent_or_size[leader(u)];",
            "    }",
            "",
            "    // It divides the graph into connected components and returns the list of them",
            "    vector<vector<int>> groups() {",
            "        vector<int> leader_buf(_n), group_size(_n);",
            "        FOR(i,0,_n-1) {",
            "            leader_buf[i] = leader(i);",
            "            group_size[leader_buf[i]]++;",
            "        }",
            "        vector<vector<int>> result(_n);",
            "        FOR(i,0,_n-1) result[i].reserve(group_size[i]);",
            "        FOR(i,0,_n-1) result[leader_buf[i]].push_back(i);",
            "        result.erase(",
            "            std::remove_if(result.begin(), result.end(),",
            "                           [&](const std::vector<int>& v) { return v.empty(); }),",
            "            result.end());",
            "        return result;",
            "    }",
            "",
            "  private:",
            "    int _n;",
            "    vector<int> parent_or_size;",
            "};"
        ],
        "description": "Disjoint Set Union"
    },
    "Static Range Sum": {
        "prefix": "zzStaticRangeSum",
        "body": [
            "struct StaticRangeSum {",
            "  public:",
            "    // inits an original array and prefix sum array with size n",
            "    StaticRangeSum() : _n(0) {}",
            "    StaticRangeSum(int n) : _n(n), elements(n, 0), prefix_sums(n, 0) {}",
            "",
            "    // a[u] = val",
            "    void assign(int u, ll val) {",
            "        assert(0 <= u && u < _n);",
            "        elements[u] = val;",
            "    }",
            "",
            "    // calculates prefix sum array",
            "    void calculate() {",
            "        if (_n == 0) return;",
            "        prefix_sums[0] = elements[0];",
            "        FOR(i,1,_n-1) prefix_sums[i] = prefix_sums[i-1] + elements[i];",
            "    }",
            "",
            "    // gets sum a[i] with i is in [l, r)",
            "    ll getSum(int l, int r) {",
            "        assert(0 <= l && l < _n);",
            "        assert(0 < r && r <= _n);",
            "        assert(l < r);",
            "        if (l == 0) return prefix_sums[r-1];",
            "        return prefix_sums[r-1] - prefix_sums[l-1];",
            "    }",
            "",
            "  private:",
            "    int _n;",
            "    vector<ll> elements, prefix_sums;",
            "};"
        ],
        "description": "Static Range Sum"
    },
    "Static RMQ": {
        "prefix": "zzStaticRMQ",
        "body": [
            "template <typename T, T (*op)(T, T)>",
            "struct SparseTable {",
            "  public:",
            "    // creates a sparse table size n with default value",
            "    SparseTable(int n, T def) {",
            "        _n = n;",
            "        elements.resize(n);",
            "        fill(ALL(elements), def);",
            "",
            "        _b = 0;",
            "        while ((1 << _b) <= n) _b++;",
            "        sparse_table.resize(n, vector<T>(_b));",
            "    }",
            "",
            "    // calculate sparse table",
            "    void proceed() {",
            "        FOR(i,0,_n-1) sparse_table[i][0] = elements[i];",
            "        FOR(j,1,_b-1)",
            "            for (int i = 0; i + (1 << j) <= _n; i++) ",
            "                sparse_table[i][j] = op(sparse_table[i][j-1], sparse_table[i + (1 << (j-1))][j-1]);",
            "    }",
            "",
            "    // set a[u] = val, not changing sparse table",
            "    void assign(int u, T val) {",
            "        assert(0 <= u && u < _n);",
            "        elements[u] = val;",
            "    }",
            "",
            "    // get op(a[i]) with i is in [l, r)",
            "    T query(int l, int r) {",
            "        assert(0 <= l && l < _n);",
            "        assert(0 < r && r <= _n);",
            "        assert(l < r);",
            "        int k = log2(r-l);",
            "        return op(sparse_table[l][k], sparse_table[r - (1 << k)][k]);",
            "    }",
            "",
            "  private:",
            "    vector<vector<T>> sparse_table;",
            "    vector<T> elements;",
            "    int _n, _b;",
            "};",
            "",
            "int f(const int a, const int b) { return min(a, b); }"
        ],
        "description": "Static RMQ"
    },
    "Binary Indexed Tree": {
        "prefix": "zzBinaryIndexedTree",
        "body": [
            "struct BinaryIndexedTree {",
            "    public:",
            "    // 1-indexed",
            "    BinaryIndexedTree(int n) {",
            "        N = n;",
            "        t.resize(N+1);",
            "        FOR(i,0,N) t[i] = 0;",
            "    }",
            "",
            "    void update(int u, int val) {",
            "        while (u <= N) {",
            "            t[u] += val;",
            "            u = u + (u & (-u));",
            "        }",
            "    }",
            " ",
            "    ll get(int u) {",
            "        ll res = 0;",
            "        while (u) {",
            "            res += t[u];",
            "            u = u - (u & (-u));",
            "        }",
            "        return res;",
            "    }",
            "",
            "    private:",
            "    vector<ll> t;",
            "    int N;",
            "};"
        ],
        "description": "Binary Indexed Tree"
    },
    "Segment Tree": {
        "prefix": "zzSegmentTree",
        "body": [
            "struct SegmentTree {",
            "    public:",
            "    int N;",
            "",
            "    // 0-indexed",
            "    SegmentTree(int n) {",
            "        t.resize(4*n);",
            "        N = n;",
            "        FOR(i,0,SZ(t)-1) t[i] = Data(1, 0);",
            "    }",
            "",
            "    SegmentTree(vector<Data> &a) {",
            "        t.resize(4*SZ(a));",
            "        N = SZ(a);",
            "        build(1, 0, N-1, a);",
            "    }",
            "",
            "    Data get(int k, int l, int r, int u, int v) {",
            "        if (l > r || r < u || v < l) return Data(1, 0);",
            "        if (u <= l && r <= v) return t[k];",
            "        int m = (l + r) >> 1;",
            "        Data lef = get(k*2, l, m, u, v);",
            "        Data rig = get(k*2+1, m+1, r, u, v);",
            "        return merge(lef, rig);",
            "    }",
            "",
            "    void update(int k, int l, int r, int u, Data val) {",
            "        if (l > r || r < u || u < l) return;",
            "        if (l == r) {",
            "            t[k] = val;",
            "            return;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        update(k*2, l, m, u, val);",
            "        update(k*2+1, m+1, r, u, val);",
            "        t[k] = merge(t[k*2], t[k*2+1]);",
            "    }",
            "",
            "    private:",
            "    vector<Data> t;",
            "",
            "    void build(int k, int l, int r, vector<Data> &a) {",
            "        if (l > r) return;",
            "        if (l == r) {",
            "            t[k] = a[l];",
            "            return;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        build(k*2, l, m, a);",
            "        build(k*2+1, m+1, r, a);",
            "        t[k] = merge(t[k*2], t[k*2+1]);",
            "    }",
            "",
            "    Data merge(Data &a, Data &b) {",
            "        return Data(b.a * a.a % MOD, (b.b + b.a * a.b) % MOD);",
            "    }",
            "};"
        ],
        "description": "Segment Tree"
    },
    "Segment Tree Lazy": {
        "prefix": "zzSegmentTreeLazy",
        "body": [
            "struct SegmentTreeLazy {",
            "    public:",
            "    int N;",
            "",
            "    // 0-indexed",
            "    SegmentTreeLazy(int n) {",
            "        t.resize(4*n);",
            "        lazy.resize(4*n);",
            "        N = n;",
            "        FOR(i,0,SZ(t)-1) {",
            "            t[i] = 0;",
            "            lazy[i] = Data(1, 0);",
            "        }",
            "    }",
            "",
            "    SegmentTreeLazy(vector<ll> &a) {",
            "        t.resize(4*SZ(a));",
            "        lazy.resize(4*SZ(a));",
            "        N = SZ(a);",
            "        build(1, 0, N-1, a);",
            "        FOR(i,0,SZ(t)-1) lazy[i] = Data(1, 0);",
            "    }",
            "",
            "    ll get(int k, int l, int r, int u, int v) {",
            "        lazyUpdate(k, l, r);",
            "        if (l > r || r < u || v < l) return 0;",
            "        if (u <= l && r <= v) return t[k];",
            "        int m = (l + r) >> 1;",
            "        ll lef = get(k*2, l, m, u, v);",
            "        ll rig = get(k*2+1, m+1, r, u, v);",
            "        return merge(lef, rig);",
            "    }",
            "",
            "    void lazyUpdate(int k, int l, int r) {",
            "        if (l > r) return;",
            "        if (lazy[k] == Data(1, 0)) return;",
            "        t[k] = (t[k] * lazy[k].a + lazy[k].b * (r - l + 1)) % MOD;",
            "        if (l < r) {",
            "            lazy[k*2] = mergeLazy(lazy[k*2], lazy[k]);",
            "            lazy[k*2+1] = mergeLazy(lazy[k*2+1], lazy[k]);",
            "        }",
            "        lazy[k] = Data(1, 0);",
            "    }",
            "",
            "    void update(int k, int l, int r, int u, int v, Data val) {",
            "        lazyUpdate(k, l, r);",
            "        if (l > r || r < u || v < l) return;",
            "        if (u <= l && r <= v) {",
            "            lazy[k] = val;",
            "            lazyUpdate(k, l, r);",
            "            return;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        update(k*2, l, m, u, v, val);",
            "        update(k*2+1, m+1, r, u, v, val);",
            "        t[k] = merge(t[k*2], t[k*2+1]);",
            "    }",
            "",
            "    private:",
            "    vector<ll> t;",
            "    vector<Data> lazy;",
            "",
            "    void build(int k, int l, int r, vector<ll> &a) {",
            "        if (l > r) return;",
            "        if (l == r) {",
            "            t[k] = a[l];",
            "            return;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        build(k*2, l, m, a);",
            "        build(k*2+1, m+1, r, a);",
            "        t[k] = merge(t[k*2], t[k*2+1]);",
            "    }",
            "",
            "    ll merge(ll &a, ll &b) {",
            "        return (a+b) % MOD;",
            "    }",
            "",
            "    Data mergeLazy(Data &ol, Data &ne) {",
            "        return Data(ne.a * ol.a % MOD, (ne.b + ne.a * ol.b) % MOD);",
            "    }",
            "};"
        ],
        "description": "Segment Tree Lazy"
    }
}