{
    "CP Starter": {
        "prefix": "zzCPStarter",
        "body": [
            "/*",
            "    Author: Nguyen Tan Bao",
            "    Status:",
            "    Idea:",
            "*/",
            "",
            "#include <bits/stdc++.h>",
            "#define FI first",
            "#define SE second",
            "#define EPS 1e-9",
            "#define ALL(a) a.begin(),a.end()",
            "#define SZ(a) int((a).size())",
            "#define MS(s, n) memset(s, n, sizeof(s))",
            "#define FOR(i,a,b) for (int i = (a); i <= (b); i++)",
            "#define FORE(i,a,b) for (int i = (a); i >= (b); i--)",
            "#define FORALL(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)",
            "//__builtin_ffs(x) return 1 + index of least significant 1-bit of x",
            "//__builtin_clz(x) return number of leading zeros of x",
            "//__builtin_ctz(x) return number of trailing zeros of x",
            "",
            "using namespace std;",
            "using ll = long long;",
            "using ld = double;",
            "typedef pair<int, int> II;",
            "typedef pair<II, int> III;",
            "typedef complex<ld> cd;",
            "typedef vector<cd> vcd;",
            "",
            "const ll MODBASE = 1000000007LL;",
            "const int MAXN = 110;",
            "const int MAXM = 1000;",
            "const int MAXK = 16;",
            "const int MAXQ = 200010;",
            "",
            "int main() {",
            "    ios::sync_with_stdio(0);",
            "    cin.tie(nullptr);",
            "    return 0;",
            "}",
            ""
        ],
        "description": "CP Starter"
    },
    "GCD Function": {
        "prefix": "zzGCDFunction",
        "body": [
            "int gcd(int a, int b) {",
            "    while (b) {",
            "        a %= b;",
            "        swap(a, b);",
            "    }",
            "    return a;",
            "}"
        ],
        "description": "GCD Function"
    },
    "Sieve of Eratosthenes": {
        "prefix": "zzSieveBase",
        "body": [
            "void sieveBase(int n) {",
            "    FOR(i,2,n) {",
            "        if (nt[i] == 0) {",
            "            nt[i] = i;",
            "            for (ll j = (ll) i * i; j <= n; j += i) nt[j] = i;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Sieve of Eratosthenes"
    },
    "Binary Exponentiation": {
        "prefix": "zzBinPowMod",
        "body": [
          "ll binPowMod(ll a, ll b) {",
          "    a %= MOD;",
          "    ll res = 1;",
          "    while (b > 0) {",
          "        if (b & 1LL) res = res * a % MOD;",
          "        a = a * a % MOD;",
          "        b >>= 1LL;",
          "    }",
          "    return res;",
          "}",
          "",
          "ll add(ll a, ll b) {",
          "    return (a + b) % MOD;",
          "}",
          "",
          "ll sub(ll a, ll b) {",
          "    return (a - b + MOD) % MOD;",
          "}",
          "",
          "ll mul(ll a, ll b) {",
          "    return a * b % MOD;",
          "}"
        ],
        "description": "Binary Exponentiation"
    },
    "Extended Euclid Algorithm": {
        "prefix": "zzExtendedEuclid",
        "body": [
            "int extendedEuclid(int a, int b, int &x, int &y) {",
            "    if (b == 0) {",
            "        x = 1;",
            "        y = 0;",
            "        return a;",
            "    }",
            "    int X1, Y1;",
            "    int d = extendedEuclid(b, a % b, X1, Y1);",
            "    x = Y1;",
            "    y = X1 - Y1 * (a / b);",
            "    return d;",
            "}"
        ],
        "description": "Extended Euclid Algorithm"
    },
    "Disjoint Set Union": {
        "prefix": "zzDSU",
        "body": [
            "struct DisjointSetUnion {",
            "  public:",
            "    // creates an undirected graph with n vertices and 0 edges.",
            "    DisjointSetUnion() : _n(0) {}",
            "    DisjointSetUnion(int n) : _n(n), parent_or_size(n, -1) {}",
            "",
            "    // add an edge (u, v)",
            "    // If the vertices u and v were in the same connected component, ",
            "    // it returns the representative of this connected component. ",
            "    // Otherwise, it returns the representative of the new connected component.",
            "    int merge(int u, int v) {",
            "        assert(0 <= u && u < _n);",
            "        assert(0 <= v && v < _n);",
            "        int x = leader(u), y = leader(v);",
            "        if (x == y) return x;",
            "        if (-parent_or_size[x] < -parent_or_size[y]) swap(x, y);",
            "        parent_or_size[x] += parent_or_size[y];",
            "        parent_or_size[y] = x;",
            "        return x;",
            "    }",
            "",
            "    // It returns whether the vertices u and v are in the same connected component",
            "    bool same(int u, int v) {",
            "        assert(0 <= u && u < _n);",
            "        assert(0 <= v && v < _n);",
            "        return leader(u) == leader(v);",
            "    }",
            "",
            "    // It returns the representative of the connected component that contains the vertex u",
            "    int leader(int u) {",
            "        assert(0 <= u && u < _n);",
            "        if (parent_or_size[u] < 0) return u;",
            "        return parent_or_size[u] = leader(parent_or_size[u]);",
            "    }",
            "",
            "    // It returns the size of the connected component that contains the vertex u",
            "    int size(int u) {",
            "        assert(0 <= u && u < _n);",
            "        return -parent_or_size[leader(u)];",
            "    }",
            "",
            "    // It divides the graph into connected components and returns the list of them",
            "    vector<vector<int>> groups() {",
            "        vector<int> leader_buf(_n), group_size(_n);",
            "        FOR(i,0,_n-1) {",
            "            leader_buf[i] = leader(i);",
            "            group_size[leader_buf[i]]++;",
            "        }",
            "        vector<vector<int>> result(_n);",
            "        FOR(i,0,_n-1) result[i].reserve(group_size[i]);",
            "        FOR(i,0,_n-1) result[leader_buf[i]].push_back(i);",
            "        result.erase(",
            "            std::remove_if(result.begin(), result.end(),",
            "                           [&](const std::vector<int>& v) { return v.empty(); }),",
            "            result.end());",
            "        return result;",
            "    }",
            "",
            "  private:",
            "    int _n;",
            "    vector<int> parent_or_size;",
            "};"
        ],
        "description": "Disjoint Set Union"
    },
    "Static Range Sum": {
        "prefix": "zzStaticRangeSum",
        "body": [
            "struct StaticRangeSum {",
            "  public:",
            "    // inits an original array and prefix sum array with size n",
            "    StaticRangeSum() : _n(0) {}",
            "    StaticRangeSum(int n) : _n(n), elements(n, 0), prefix_sums(n, 0) {}",
            "",
            "    // a[u] = val",
            "    void assign(int u, ll val) {",
            "        assert(0 <= u && u < _n);",
            "        elements[u] = val;",
            "    }",
            "",
            "    // calculates prefix sum array",
            "    void calculate() {",
            "        if (_n == 0) return;",
            "        prefix_sums[0] = elements[0];",
            "        FOR(i,1,_n-1) prefix_sums[i] = prefix_sums[i-1] + elements[i];",
            "    }",
            "",
            "    // gets sum a[i] with i is in [l, r)",
            "    ll getSum(int l, int r) {",
            "        assert(0 <= l && l < _n);",
            "        assert(0 < r && r <= _n);",
            "        assert(l < r);",
            "        if (l == 0) return prefix_sums[r-1];",
            "        return prefix_sums[r-1] - prefix_sums[l-1];",
            "    }",
            "",
            "  private:",
            "    int _n;",
            "    vector<ll> elements, prefix_sums;",
            "};"
        ],
        "description": "Static Range Sum"
    },
    "Static RMQ": {
        "prefix": "zzStaticRMQ",
        "body": [
            "template <typename T, T (*op)(T, T)>",
            "struct SparseTable {",
            "  public:",
            "    // creates a sparse table size n with default value",
            "    SparseTable(int n, T def) {",
            "        _n = n;",
            "        elements.resize(n);",
            "        fill(ALL(elements), def);",
            "",
            "        _b = 0;",
            "        while ((1 << _b) <= n) _b++;",
            "        sparse_table.resize(n, vector<T>(_b));",
            "    }",
            "",
            "    // calculate sparse table",
            "    void proceed() {",
            "        FOR(i,0,_n-1) sparse_table[i][0] = elements[i];",
            "        FOR(j,1,_b-1)",
            "            for (int i = 0; i + (1 << j) <= _n; i++) ",
            "                sparse_table[i][j] = op(sparse_table[i][j-1], sparse_table[i + (1 << (j-1))][j-1]);",
            "    }",
            "",
            "    // set a[u] = val, not changing sparse table",
            "    void assign(int u, T val) {",
            "        assert(0 <= u && u < _n);",
            "        elements[u] = val;",
            "    }",
            "",
            "    // get op(a[i]) with i is in [l, r)",
            "    T query(int l, int r) {",
            "        assert(0 <= l && l < _n);",
            "        assert(0 < r && r <= _n);",
            "        assert(l < r);",
            "        int k = log2(r-l);",
            "        return op(sparse_table[l][k], sparse_table[r - (1 << k)][k]);",
            "    }",
            "",
            "  private:",
            "    vector<vector<T>> sparse_table;",
            "    vector<T> elements;",
            "    int _n, _b;",
            "};",
            "",
            "int f(const int a, const int b) { return min(a, b); }"
        ],
        "description": "Static RMQ"
    },
    "Binary Indexed Tree": {
        "prefix": "zzBinaryIndexedTree",
        "body": [
            "struct BinaryIndexedTree {",
            "    public:",
            "    // 1-indexed",
            "    BinaryIndexedTree(int n) {",
            "        N = n;",
            "        t.resize(N+1);",
            "        FOR(i,0,N) t[i] = 0;",
            "    }",
            "",
            "    void update(int u, int val) {",
            "        while (u <= N) {",
            "            t[u] += val;",
            "            u = u + (u & (-u));",
            "        }",
            "    }",
            " ",
            "    ll get(int u) {",
            "        ll res = 0;",
            "        while (u) {",
            "            res += t[u];",
            "            u = u - (u & (-u));",
            "        }",
            "        return res;",
            "    }",
            "",
            "    private:",
            "    vector<ll> t;",
            "    int N;",
            "};"
        ],
        "description": "Binary Indexed Tree"
    },
    "Segment Tree": {
        "prefix": "zzSegmentTree",
        "body": [
            "struct SegmentTree {",
            "    public:",
            "    int N;",
            "",
            "    // 0-indexed",
            "    SegmentTree(int n) {",
            "        t.resize(4*n);",
            "        N = n;",
            "        FOR(i,0,SZ(t)-1) t[i] = Data(1, 0);",
            "    }",
            "",
            "    SegmentTree(vector<Data> &a) {",
            "        t.resize(4*SZ(a));",
            "        N = SZ(a);",
            "        build(1, 0, N-1, a);",
            "    }",
            "",
            "    Data get(int k, int l, int r, int u, int v) {",
            "        if (l > r || r < u || v < l) return Data(1, 0);",
            "        if (u <= l && r <= v) return t[k];",
            "        int m = (l + r) >> 1;",
            "        Data lef = get(k*2, l, m, u, v);",
            "        Data rig = get(k*2+1, m+1, r, u, v);",
            "        return merge(lef, rig);",
            "    }",
            "",
            "    void update(int k, int l, int r, int u, Data val) {",
            "        if (l > r || r < u || u < l) return;",
            "        if (l == r) {",
            "            t[k] = val;",
            "            return;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        update(k*2, l, m, u, val);",
            "        update(k*2+1, m+1, r, u, val);",
            "        t[k] = merge(t[k*2], t[k*2+1]);",
            "    }",
            "",
            "    private:",
            "    vector<Data> t;",
            "",
            "    void build(int k, int l, int r, vector<Data> &a) {",
            "        if (l > r) return;",
            "        if (l == r) {",
            "            t[k] = a[l];",
            "            return;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        build(k*2, l, m, a);",
            "        build(k*2+1, m+1, r, a);",
            "        t[k] = merge(t[k*2], t[k*2+1]);",
            "    }",
            "",
            "    Data merge(Data &a, Data &b) {",
            "        return Data(b.a * a.a % MOD, (b.b + b.a * a.b) % MOD);",
            "    }",
            "};"
        ],
        "description": "Segment Tree"
    },
    "Segment Tree Lazy": {
        "prefix": "zzSegmentTreeLazy",
        "body": [
            "struct SegmentTreeLazy {",
            "    public:",
            "    int N;",
            "",
            "    // 0-indexed",
            "    SegmentTreeLazy(int n) {",
            "        t.resize(4*n);",
            "        lazy.resize(4*n);",
            "        N = n;",
            "        FOR(i,0,SZ(t)-1) {",
            "            t[i] = 0;",
            "            lazy[i] = Data(1, 0);",
            "        }",
            "    }",
            "",
            "    SegmentTreeLazy(vector<ll> &a) {",
            "        t.resize(4*SZ(a));",
            "        lazy.resize(4*SZ(a));",
            "        N = SZ(a);",
            "        build(1, 0, N-1, a);",
            "        FOR(i,0,SZ(t)-1) lazy[i] = Data(1, 0);",
            "    }",
            "",
            "    ll get(int k, int l, int r, int u, int v) {",
            "        lazyUpdate(k, l, r);",
            "        if (l > r || r < u || v < l) return 0;",
            "        if (u <= l && r <= v) return t[k];",
            "        int m = (l + r) >> 1;",
            "        ll lef = get(k*2, l, m, u, v);",
            "        ll rig = get(k*2+1, m+1, r, u, v);",
            "        return merge(lef, rig);",
            "    }",
            "",
            "    void lazyUpdate(int k, int l, int r) {",
            "        if (l > r) return;",
            "        if (lazy[k] == Data(1, 0)) return;",
            "        t[k] = (t[k] * lazy[k].a + lazy[k].b * (r - l + 1)) % MOD;",
            "        if (l < r) {",
            "            lazy[k*2] = mergeLazy(lazy[k*2], lazy[k]);",
            "            lazy[k*2+1] = mergeLazy(lazy[k*2+1], lazy[k]);",
            "        }",
            "        lazy[k] = Data(1, 0);",
            "    }",
            "",
            "    void update(int k, int l, int r, int u, int v, Data val) {",
            "        lazyUpdate(k, l, r);",
            "        if (l > r || r < u || v < l) return;",
            "        if (u <= l && r <= v) {",
            "            lazy[k] = val;",
            "            lazyUpdate(k, l, r);",
            "            return;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        update(k*2, l, m, u, v, val);",
            "        update(k*2+1, m+1, r, u, v, val);",
            "        t[k] = merge(t[k*2], t[k*2+1]);",
            "    }",
            "",
            "    private:",
            "    vector<ll> t;",
            "    vector<Data> lazy;",
            "",
            "    void build(int k, int l, int r, vector<ll> &a) {",
            "        if (l > r) return;",
            "        if (l == r) {",
            "            t[k] = a[l];",
            "            return;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        build(k*2, l, m, a);",
            "        build(k*2+1, m+1, r, a);",
            "        t[k] = merge(t[k*2], t[k*2+1]);",
            "    }",
            "",
            "    ll merge(ll &a, ll &b) {",
            "        return (a+b) % MOD;",
            "    }",
            "",
            "    Data mergeLazy(Data &ol, Data &ne) {",
            "        return Data(ne.a * ol.a % MOD, (ne.b + ne.a * ol.b) % MOD);",
            "    }",
            "};"
        ],
        "description": "Segment Tree Lazy"
    },
    "Implicit Treap": {
        "prefix": "zzImplicitTreap",
        "body": [
            "mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());",
            "struct Treap {",
            "    struct node {",
            "        int prior, val, sz;",
            "        bool rev;",
            "        node *l, *r;",
            "",
            "        node(int _val = 0) {",
            "            val = _val;",
            "            prior = rnd();",
            "            sz = 1;",
            "            rev = 0;",
            "            l = r = NULL;",
            "        }",
            "    };",
            "    typedef node* pnode;",
            "    pnode root;",
            "",
            "    void clear() {",
            "        root = NULL;",
            "    }",
            "",
            "    Treap() {",
            "        clear();",
            "    }",
            "",
            "    int size(pnode it) {",
            "        return it ? it->sz : 0;",
            "    }",
            "",
            "    void recalc(pnode it) {",
            "        if (it) {",
            "            it->sz = size(it->l) + size(it->r) + 1;",
            "        }",
            "    }",
            "",
            "    void push(pnode it) {",
            "        if (it && it->rev) {",
            "            it->rev = 0;",
            "            swap(it->l, it->r);",
            "            if (it->l) it->l->rev ^= 1;",
            "            if (it->r) it->r->rev ^= 1;",
            "        }",
            "    }",
            "",
            "    void merge(pnode &t, pnode l, pnode r) {",
            "        // largest key of tree l should be smaller than smallest key of tree r",
            "        push(l);",
            "        push(r);",
            "        if (!l || !r) t = l ? l : r;",
            "        else if (l->prior > r->prior) merge(l->r, l->r, r), t = l;",
            "        else merge(r->l, l, r->l), t = r;",
            "        recalc(t);",
            "    }",
            "",
            "    void split(pnode t, pnode &l, pnode &r, int key, int add = 0) {",
            "        if (!t) {",
            "            l = r = NULL;",
            "            return;",
            "        }",
            "        push(t);",
            "        int curKey = add + size(t->l);",
            "        // right tree has keys >= key",
            "        // left tree has keys < key",
            "        if (key <= curKey) split (t->l, l, t->l, key, add), r = t;",
            "        else split (t->r, t->r, r, key, add + 1 + size(t->l)), l = t;",
            "        recalc(t);",
            "    }",
            "",
            "    // reverse all the values from qL to qR",
            "    void reverse(int qL, int qR) {",
            "        assert(0 <= qL && qL <= qR && qR < size(root));",
            "        pnode l, r, mid;",
            " ",
            "        split(root, l, r, qL);",
            "        split(r, mid, r, qR - qL + 1);",
            " ",
            "        mid->rev ^= 1;",
            "        merge(r, mid, r);",
            "        merge(root, l, r);",
            "    }",
            "",
            "    void output(pnode t) {",
            "        if (!t) return;",
            "        push(t);",
            "        output(t->l);",
            "        printf(\"%d \", t->val);",
            "        output(t->r);",
            "    }",
            "",
            "    bool insert(int pos, int val) {",
            "        if (!(0 <= pos && pos <= size(root))) return false;",
            "        if (!root) {",
            "            pnode to_add = new node(val);",
            "            root = to_add;",
            "            return true;",
            "        }",
            " ",
            "        pnode l, r, mid;",
            "        mid = new node(val);",
            " ",
            "        split(root, l, r, pos);",
            "        merge(l, l, mid);",
            "        merge(root, l, r);",
            "        return true;",
            "    }",
            "",
            "    int getVal(pnode &t, int pos, int add = 0) {",
            "        if (!t) return -1;",
            "        push(t);",
            "        int curKey = add + size(t->l);",
            "        if (pos == curKey) return t->val;",
            "        if (pos < curKey) return getVal(t->l, pos, add);",
            "        return getVal(t->r, pos, add + 1 + size(t->l));",
            "    }",
            "",
            "    int getVal(int pos) {",
            "        return getVal(root, pos);",
            "    }",
            "",
            "    int remove(int pos) {",
            "        pnode l, r, mid;",
            "        split(root, l, r, pos);",
            "        split(r, mid, r, 1);",
            "        int res = mid ? mid->val : 0;",
            "        merge(root, l, r);",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Implicit Treap"
    },
    "Ordinary Treap": {
        "prefix": "zzOrdinaryTreap",
        "body": [
            "mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());",
            "struct OrdinaryTreap {",
            "    struct node {",
            "        int key, prior, sz;",
            "        node *l, *r;",
            "",
            "        node(int _key = 0) {",
            "            key = _key;",
            "            prior = rnd();",
            "            sz = 1;",
            "            l = r = NULL;",
            "        }",
            "    };",
            "    typedef node* pnode;",
            "    pnode root;",
            "",
            "    void clear() {",
            "        root = NULL;",
            "    }",
            "",
            "    OrdinaryTreap() {",
            "        clear();",
            "    }",
            "",
            "    int size(pnode it) {",
            "        return it ? it->sz : 0;",
            "    }",
            "",
            "    void recalc(pnode it) {",
            "        if (it) {",
            "            it->sz = size(it->l) + size(it->r) + 1;",
            "        }",
            "    }",
            "",
            "    void merge(pnode &t, pnode l, pnode r) {",
            "        // largest key of tree l should be smaller than smallest key of tree r",
            "        if (!l || !r) t = l ? l : r;",
            "        else if (l->prior > r->prior) merge(l->r, l->r, r), t = l;",
            "        else merge(r->l, l, r->l), t = r;",
            "        recalc(t);",
            "    }",
            "",
            "    void split(pnode t, pnode &l, pnode &r, int key) {",
            "        if (!t) {",
            "            l = r = NULL;",
            "            return;",
            "        }",
            "        // right tree has keys >= key",
            "        // left tree has keys < key",
            "        if (key <= t->key) split(t->l, l, t->l, key), r = t;",
            "        else split(t->r, t->r, r, key), l = t;",
            "        recalc(t);",
            "    }",
            "",
            "    void insert(pnode &t, pnode it) {",
            "        if (!t) t = it;",
            "        else if (it->prior > t->prior) split(t, it->l, it->r, it->key), t = it;",
            "        else insert(it->key < t->key ? t->l : t->r, it);",
            "        recalc(t);",
            "    }",
            "",
            "    void insert(int u) {",
            "        pnode w = new node(u);",
            "        insert(root, w);",
            "    }",
            "",
            "    bool search(pnode &t, int key) {",
            "        if (!t) return false;",
            "        bool co = false;",
            "        if (key == t->key) co = true;",
            "        else if (key < t->key) co |= search(t->l, key);",
            "        else co |= search(t->r, key);",
            "        recalc(t);",
            "        return co;",
            "    }",
            "",
            "    bool search(int key) {",
            "        return search(root, key);",
            "    }",
            "",
            "    void remove(pnode &t, int key) {",
            "        if (!t) return;",
            "        if (key == t->key) merge(t, t->l, t->r);",
            "        else remove(key < t->key ? t->l : t->r, key);",
            "        recalc(t);",
            "    }",
            "",
            "    void remove(int pos) {",
            "        return remove(root, pos);",
            "    }",
            "",
            "    int findPos(pnode &t, int key) {",
            "        if (!t) return -1;",
            "        if (key == t->key) return 1 + size(t->l);",
            "        else if (key > t->key) {",
            "            int e = findPos(t->r, key);",
            "            if (e != -1) return 1 + size(t->l) + e;",
            "            return -1;",
            "        }",
            "        return findPos(t->l, key);",
            "    }",
            "",
            "    int findPos(int val) {",
            "        return findPos(root, val);",
            "    }",
            "",
            "    int getVal(pnode &t, int pos) {",
            "        if (!t) return -1;",
            "",
            "        int e = size(t->l);",
            "        if (e >= pos) return getVal(t->l, pos);",
            "",
            "        pos -= e;",
            "        if (pos == 1) return t->key;",
            "",
            "        pos--;",
            "        return getVal(t->r, pos);",
            "    }",
            "",
            "    int getVal(int pos) {",
            "        if (size(root) < pos) return -1;",
            "        return getVal(root, pos);",
            "    }",
            "};"
        ],
        "description": "Ordinary Treap"
    },
    "Persistent Segment Tree": {
        "prefix": "zzPersistentSegmentTree",
        "body": [
            "struct Vertex {",
            "    Vertex *l, *r;",
            "    ll sum;",
            "",
            "    Vertex(int val) : l(nullptr), r(nullptr), sum(val) {}",
            "    Vertex(Vertex *l, Vertex *r) : l(l), r(r), sum(0) {",
            "        if (l) sum += l->sum;",
            "        if (r) sum += r->sum;",
            "    }",
            "};",
            "",
            "struct PersistentSegmentTree {",
            "    public:",
            "    int N;",
            "    vector <Vertex*> versions;",
            "",
            "    PersistentSegmentTree(int n) {",
            "        N = n;",
            "        vector<int> a(N, 0);",
            "        versions.push_back(build(0, N-1, a));",
            "    }",
            "",
            "    ll get(Vertex* ve, int l, int r, int u, int v) {",
            "        if (l > r || v < l || r < u) return 0;",
            "        if (u <= l && r <= v) return ve->sum;",
            "        int m = (l + r) >> 1;",
            "        return get(ve->l, l, m, u, v) + get(ve->r, m+1, r, u, v);",
            "    }",
            "",
            "    Vertex* update(Vertex *ve, int l, int r, int u, int val) {",
            "        if (l == r) return new Vertex(val);",
            "        int m = (l + r) >> 1;",
            "        if (u <= m) return new Vertex(update(ve->l, l, m, u, val), ve->r);",
            "        return new Vertex(ve->l, update(ve->r, m+1, r, u, val));",
            "    }",
            "",
            "    private:",
            "    Vertex* build(int l, int r, vector<int> &a) {",
            "        if (l == r) return new Vertex(a[l]);",
            "        int m = (l + r) >> 1;",
            "        return new Vertex(build(l, m, a), build(m+1, r, a));",
            "    }",
            "};"
        ],
        "description": "Persistent Segment Tree"
    }
}