{
    "CP Starter": {
        "prefix": "zzCPStarter",
        "body": [
            "/*",
            "    Template Version: 1.0.0 - 20220620",
            "    Author: Nguyen Tan Bao",
            "    Status:",
            "    Idea:",
            "*/",
            "",
            "#include <bits/stdc++.h>",
            "#define FI first",
            "#define SE second",
            "#define ALL(a) a.begin(), a.end()",
            "#define SZ(a) int((a).size())",
            "#define MS(s, n) memset(s, n, sizeof(s))",
            "#define FOR(i,a,b) for (int i = (a); i <= (b); i++)",
            "#define FORE(i,a,b) for (int i = (a); i >= (b); i--)",
            "#define FORALL(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)",
            "#define TRAV(x, a) for (auto &x : a)",
            "",
            "using namespace std;",
            "using ll = long long; using ld = double; ",
            "using pi = pair<int, int>; using pl = pair<ll, ll>; using pd = pair<ld, ld>;",
            "using cd = complex<ld>; using vcd = vector<cd>;",
            "",
            "using vi = vector<int>; using vl = vector<ll>;",
            "using vd = vector<ld>; using vs = vector<string>;",
            "using vpi = vector<pi>; using vpl = vector<pl>; using vpd = vector<pd>; // vector<pair>",
            "",
            "template<class T> using min_pq = priority_queue<T, vector<T>, greater<T> >;",
            "template<class T> inline int ckmin(T& a, const T& val) { return val < a ? a = val, 1 : 0; }",
            "template<class T> inline int ckmax(T& a, const T& val) { return a < val ? a = val, 1 : 0; }",
            "template<class T> void remDup(vector<T>& v) { sort(ALL(v)); v.erase(unique(ALL(v)), end(v)); }",
            "",
            "constexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set",
            "constexpr int bits(int x) { return x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) ",
            "constexpr int p2(int x) { return 1<<x; }",
            "constexpr int msk2(int x) { return p2(x)-1; }",
            "",
            "ll ceilDiv(ll a, ll b) { return a / b + ((a ^ b) > 0 && a % b); } // divide a by b rounded up",
            "ll floorDiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); } // divide a by b rounded down",
            "void setPrec(int x) { cout << fixed << setprecision(x); }",
            "",
            "// TO_STRING",
            "#define ts to_string",
            "string ts(char c) { return string(1, c); }",
            "string ts(const char* s) { return (string) s; }",
            "string ts(string s) { return s; }",
            "string ts(bool b) { return (b ? \"true\" : \"false\"); }",
            "",
            "template<class T> using V = vector<T>;",
            "template<class T> string ts(complex<T> c);",
            "string ts(V<bool> v);",
            "template<size_t sz> string ts(bitset<sz> b);",
            "template<class T> string ts(T v);",
            "template<class T, class U> string ts(pair<T,U> p);",
            "template<class ...U> string ts(tuple<U...> u);",
            "",
            "template<class T> string ts(complex<T> c) { stringstream ss; ss << c; return ss.str(); }",
            "string ts(V<bool> v) {string res = \"{\"; FOR(i,0,SZ(v)-1) res += char('0'+v[i]); res += \"}\"; return res; }",
            "template<size_t sz> string ts(bitset<sz> b) { string res = \"\"; FOR(i,0,SZ(b)-1) res += char('0'+b[i]); return res; }",
            "template<class T> string ts(T v) { // containers with begin(), end()",
            "    bool fst = 1; string res = \"\";",
            "    for (const auto& x: v) { if (!fst) res += \" \"; fst = 0; res += ts(x); }",
            "    return res;",
            "}",
            "template<class T, class U> string ts(pair<T,U> p) { return \"(\" + ts(p.FI) + \", \" + ts(p.SE) + \")\"; }",
            "template<size_t i, class T> string print_tuple_utils(const T& tup) { if constexpr(i == tuple_size<T>::value) return \")\"; else return (i ? \", \" : \"(\") + ts(get<i>(tup)) + print_tuple_utils<i + 1, T>(tup); }",
            "template<class ...U> string ts(tuple<U...> u) { return print_tuple_utils<0, tuple<U...>>(u); }",
            "",
            "// OUTPUT",
            "template<class T> void pr(T x) { cout << ts(x); }",
            "template<class T, class ...U> void pr(const T& t, const U&... u) { pr(t); pr(u...); }",
            "void ps() { pr(\"\\n\"); } // print w/ spaces",
            "template<class T, class ...U> void ps(const T& t, const U&... u) { pr(t); if (sizeof...(u)) pr(\" \"); ps(u...); }",
            "",
            "// DEBUG",
            "void DBG() { cerr << \"]\" << endl; }",
            "template<class T, class ...U> void DBG(const T& t, const U&... u) { cerr << ts(t); if (sizeof...(u)) cerr << \", \"; DBG(u...); }",
            "",
            "#ifdef LOCAL_DEBUG",
            "#define CONCAT(x, y) x##y",
            "#define with_level setw(__db_level * 2) << setfill(' ') << \"\" << setw(0)",
            "#define dbg(...) cerr << with_level << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)",
            "#define chk(...) if (!(__VA_ARGS__)) cerr << setw(__db_level * 2) << setfill(' ') << \"\" << setw(0) << \"Line(\" << __LINE__ << \") -> function(\" << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);",
            "#define db_block() debug_block CONCAT(dbbl, __LINE__)",
            "int __db_level = 0;",
            "struct debug_block {",
            "    debug_block() { cerr << with_level << \"{\" << endl; ++__db_level; }",
            "    ~debug_block() { --__db_level; cerr << with_level << \"}\" << endl; }",
            "};",
            "#else",
            "#define dbg(...) 0",
            "#define chk(...) 0",
            "#define db_block() 0",
            "#endif",
            "",
            "const ld PI = acos(-1.0);",
            "const int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};",
            "const ld EPS = 1e-9;",
            "const ll MODBASE = 1000000007LL;",
            "const int INF = 0x3f3f3f3f;",
            "",
            "const int MAXN = 110;",
            "const int MAXM = 1000;",
            "const int MAXK = 16;",
            "const int MAXQ = 200010;",
            "",
            "int main() {",
            "    ios::sync_with_stdio(0);",
            "    cin.tie(nullptr);",
            "    return 0;",
            "}",
            ""
        ],
        "description": "CP Starter"
    },
    "GCD Function": {
        "prefix": "zzGCDFunction",
        "body": [
            "int gcd(int a, int b) {",
            "    while (b) {",
            "        a %= b;",
            "        swap(a, b);",
            "    }",
            "    return a;",
            "}"
        ],
        "description": "GCD Function"
    },
    "Sieve of Eratosthenes": {
        "prefix": "zzSieveBase",
        "body": [
            "void sieveBase(int n) {",
            "    FOR(i,2,n) {",
            "        if (nt[i] == 0) {",
            "            nt[i] = i;",
            "            for (ll j = (ll) i * i; j <= n; j += i) nt[j] = i;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Sieve of Eratosthenes"
    },
    "Modular Arithmetic": {
        "prefix": "zzModInt",
        "body": [
            "template<int MOD> struct mint {",
            "    static const int mod = MOD;",
            "    int v; explicit operator int() const { return v; } // explicit -> don't silently convert to int",
            "    mint() { v = 0; }",
            "    mint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);",
            "        if (v < 0) v += MOD; }",
            "    friend bool operator==(const mint& a, const mint& b) { ",
            "        return a.v == b.v; }",
            "    friend bool operator!=(const mint& a, const mint& b) { ",
            "        return !(a == b); }",
            "    friend bool operator<(const mint& a, const mint& b) { ",
            "        return a.v < b.v; }",
            "    friend string ts(mint a) { return ts(a.v); }",
            "",
            "    mint& operator+=(const mint& m) { ",
            "        if ((v += m.v) >= MOD) v -= MOD; ",
            "        return *this; }",
            "    mint& operator-=(const mint& m) { ",
            "        if ((v -= m.v) < 0) v += MOD; ",
            "        return *this; }",
            "    mint& operator*=(const mint& m) { ",
            "        v = int((ll) v * m.v % MOD); return *this; }",
            "    mint& operator/=(const mint& m) { return (*this) *= inv(m); }",
            "    friend mint pow(mint a, ll p) {",
            "        mint ans = 1; assert(p >= 0);",
            "        for (; p; p /= 2, a *= a) if (p&1) ans *= a;",
            "        return ans; }",
            "    friend mint inv(const mint& a) { assert(a.v != 0); ",
            "        return pow(a,MOD-2); }",
            "        ",
            "    mint operator-() const { return mint(-v); }",
            "    mint& operator++() { return *this += 1; }",
            "    mint& operator--() { return *this -= 1; }",
            "    friend mint operator+(mint a, const mint& b) { return a += b; }",
            "    friend mint operator-(mint a, const mint& b) { return a -= b; }",
            "    friend mint operator*(mint a, const mint& b) { return a *= b; }",
            "    friend mint operator/(mint a, const mint& b) { return a /= b; }",
            "};",
            "",
            "typedef mint<MODBASE> mi;",
            "typedef vector<mi> vmi;",
            "typedef pair<mi,mi> pmi;",
            "typedef vector<pmi> vpmi;"
        ],
        "description": "Modular Arithmetic"
    },
    "Extended Euclid Algorithm": {
        "prefix": "zzExtendedEuclid",
        "body": [
            "int extendedEuclid(int a, int b, int &x, int &y) {",
            "    if (b == 0) {",
            "        x = 1;",
            "        y = 0;",
            "        return a;",
            "    }",
            "    int X1, Y1;",
            "    int d = extendedEuclid(b, a % b, X1, Y1);",
            "    x = Y1;",
            "    y = X1 - Y1 * (a / b);",
            "    return d;",
            "}"
        ],
        "description": "Extended Euclid Algorithm"
    },
    "Disjoint Set Union": {
        "prefix": "zzDSU",
        "body": [
            "struct DisjointSetUnion {",
            "  public:",
            "    // creates an undirected graph with n vertices and 0 edges.",
            "    DisjointSetUnion() : _n(0) {}",
            "    DisjointSetUnion(int n) : _n(n), parent_or_size(n, -1) {}",
            "",
            "    // add an edge (u, v)",
            "    // If the vertices u and v were in the same connected component, ",
            "    // it returns the representative of this connected component. ",
            "    // Otherwise, it returns the representative of the new connected component.",
            "    int merge(int u, int v) {",
            "        assert(0 <= u && u < _n);",
            "        assert(0 <= v && v < _n);",
            "        int x = leader(u), y = leader(v);",
            "        if (x == y) return x;",
            "        if (-parent_or_size[x] < -parent_or_size[y]) swap(x, y);",
            "        parent_or_size[x] += parent_or_size[y];",
            "        parent_or_size[y] = x;",
            "        return x;",
            "    }",
            "",
            "    // It returns whether the vertices u and v are in the same connected component",
            "    bool same(int u, int v) {",
            "        assert(0 <= u && u < _n);",
            "        assert(0 <= v && v < _n);",
            "        return leader(u) == leader(v);",
            "    }",
            "",
            "    // It returns the representative of the connected component that contains the vertex u",
            "    int leader(int u) {",
            "        assert(0 <= u && u < _n);",
            "        if (parent_or_size[u] < 0) return u;",
            "        return parent_or_size[u] = leader(parent_or_size[u]);",
            "    }",
            "",
            "    // It returns the size of the connected component that contains the vertex u",
            "    int size(int u) {",
            "        assert(0 <= u && u < _n);",
            "        return -parent_or_size[leader(u)];",
            "    }",
            "",
            "    // It divides the graph into connected components and returns the list of them",
            "    vector<vector<int>> groups() {",
            "        vector<int> leader_buf(_n), group_size(_n);",
            "        FOR(i,0,_n-1) {",
            "            leader_buf[i] = leader(i);",
            "            group_size[leader_buf[i]]++;",
            "        }",
            "        vector<vector<int>> result(_n);",
            "        FOR(i,0,_n-1) result[i].reserve(group_size[i]);",
            "        FOR(i,0,_n-1) result[leader_buf[i]].push_back(i);",
            "        result.erase(",
            "            std::remove_if(result.begin(), result.end(),",
            "                           [&](const std::vector<int>& v) { return v.empty(); }),",
            "            result.end());",
            "        return result;",
            "    }",
            "",
            "  private:",
            "    int _n;",
            "    vector<int> parent_or_size;",
            "};"
        ],
        "description": "Disjoint Set Union"
    },
    "Static Range Sum": {
        "prefix": "zzStaticRangeSum",
        "body": [
            "struct StaticRangeSum {",
            "  public:",
            "    // inits an original array and prefix sum array with size n",
            "    StaticRangeSum() : _n(0) {}",
            "    StaticRangeSum(int n) : _n(n), elements(n, 0), prefix_sums(n, 0) {}",
            "",
            "    // a[u] = val",
            "    void assign(int u, ll val) {",
            "        assert(0 <= u && u < _n);",
            "        elements[u] = val;",
            "    }",
            "",
            "    // calculates prefix sum array",
            "    void calculate() {",
            "        if (_n == 0) return;",
            "        prefix_sums[0] = elements[0];",
            "        FOR(i,1,_n-1) prefix_sums[i] = prefix_sums[i-1] + elements[i];",
            "    }",
            "",
            "    // gets sum a[i] with i is in [l, r)",
            "    ll getSum(int l, int r) {",
            "        assert(0 <= l && l < _n);",
            "        assert(0 < r && r <= _n);",
            "        assert(l < r);",
            "        if (l == 0) return prefix_sums[r-1];",
            "        return prefix_sums[r-1] - prefix_sums[l-1];",
            "    }",
            "",
            "  private:",
            "    int _n;",
            "    vector<ll> elements, prefix_sums;",
            "};"
        ],
        "description": "Static Range Sum"
    },
    "Static RMQ": {
        "prefix": "zzStaticRMQ",
        "body": [
            "template <typename T, T (*op)(T, T)>",
            "struct SparseTable {",
            "  public:",
            "    // creates a sparse table size n with default value",
            "    SparseTable(int n, T def) {",
            "        _n = n;",
            "        elements.resize(n);",
            "        fill(ALL(elements), def);",
            "",
            "        _b = 0;",
            "        while ((1 << _b) <= n) _b++;",
            "        sparse_table.resize(n, vector<T>(_b));",
            "    }",
            "",
            "    // calculate sparse table",
            "    void proceed() {",
            "        FOR(i,0,_n-1) sparse_table[i][0] = elements[i];",
            "        FOR(j,1,_b-1)",
            "            for (int i = 0; i + (1 << j) <= _n; i++) ",
            "                sparse_table[i][j] = op(sparse_table[i][j-1], sparse_table[i + (1 << (j-1))][j-1]);",
            "    }",
            "",
            "    // set a[u] = val, not changing sparse table",
            "    void assign(int u, T val) {",
            "        assert(0 <= u && u < _n);",
            "        elements[u] = val;",
            "    }",
            "",
            "    // get op(a[i]) with i is in [l, r)",
            "    T query(int l, int r) {",
            "        assert(0 <= l && l < _n);",
            "        assert(0 < r && r <= _n);",
            "        assert(l < r);",
            "        int k = log2(r-l);",
            "        return op(sparse_table[l][k], sparse_table[r - (1 << k)][k]);",
            "    }",
            "",
            "  private:",
            "    vector<vector<T>> sparse_table;",
            "    vector<T> elements;",
            "    int _n, _b;",
            "};",
            "",
            "int f(const int a, const int b) { return min(a, b); }"
        ],
        "description": "Static RMQ"
    },
    "Binary Indexed Tree": {
        "prefix": "zzBinaryIndexedTree",
        "body": [
            "struct BinaryIndexedTree {",
            "    public:",
            "    // 1-indexed",
            "    BinaryIndexedTree(int n) {",
            "        N = n;",
            "        t.resize(N+1);",
            "        FOR(i,0,N) t[i] = 0;",
            "    }",
            "",
            "    void update(int u, int val) {",
            "        while (u <= N) {",
            "            t[u] += val;",
            "            u = u + (u & (-u));",
            "        }",
            "    }",
            " ",
            "    ll get(int u) {",
            "        ll res = 0;",
            "        while (u) {",
            "            res += t[u];",
            "            u = u - (u & (-u));",
            "        }",
            "        return res;",
            "    }",
            "",
            "    private:",
            "    vector<ll> t;",
            "    int N;",
            "};"
        ],
        "description": "Binary Indexed Tree"
    },
    "Segment Tree": {
        "prefix": "zzSegmentTree",
        "body": [
            "struct SegmentTree {",
            "    public:",
            "    int N;",
            "",
            "    // 0-indexed",
            "    SegmentTree(int n) {",
            "        t.resize(4*n);",
            "        N = n;",
            "        FOR(i,0,SZ(t)-1) t[i] = Data(1, 0);",
            "    }",
            "",
            "    SegmentTree(vector<Data> &a) {",
            "        t.resize(4*SZ(a));",
            "        N = SZ(a);",
            "        build(1, 0, N-1, a);",
            "    }",
            "",
            "    Data get(int k, int l, int r, int u, int v) {",
            "        if (l > r || r < u || v < l) return Data(1, 0);",
            "        if (u <= l && r <= v) return t[k];",
            "        int m = (l + r) >> 1;",
            "        Data lef = get(k*2, l, m, u, v);",
            "        Data rig = get(k*2+1, m+1, r, u, v);",
            "        return merge(lef, rig);",
            "    }",
            "",
            "    void update(int k, int l, int r, int u, Data val) {",
            "        if (l > r || r < u || u < l) return;",
            "        if (l == r) {",
            "            t[k] = val;",
            "            return;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        update(k*2, l, m, u, val);",
            "        update(k*2+1, m+1, r, u, val);",
            "        t[k] = merge(t[k*2], t[k*2+1]);",
            "    }",
            "",
            "    private:",
            "    vector<Data> t;",
            "",
            "    void build(int k, int l, int r, vector<Data> &a) {",
            "        if (l > r) return;",
            "        if (l == r) {",
            "            t[k] = a[l];",
            "            return;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        build(k*2, l, m, a);",
            "        build(k*2+1, m+1, r, a);",
            "        t[k] = merge(t[k*2], t[k*2+1]);",
            "    }",
            "",
            "    Data merge(Data &a, Data &b) {",
            "        return Data(b.a * a.a % MOD, (b.b + b.a * a.b) % MOD);",
            "    }",
            "};"
        ],
        "description": "Segment Tree"
    },
    "Segment Tree Lazy": {
        "prefix": "zzSegmentTreeLazy",
        "body": [
            "// Example: SegmentTreeLazy<mi, op, e, Expression, mapping, composition, id> seg(a);",
            "// Define functions like this: inline mi op(mi a, mi b) { return a + b; }",
            "template<",
            "    typename S, ",
            "    S (*op)(S, S), // merge 2 segments",
            "    S (*e)(), // initial value of a segment",
            "    typename F,",
            "    S (*mapping)(F, S, int, int), // apply lazy value to a segment",
            "    F (*composition)(F, F), // merge later lazy value to earlier lazy value",
            "    F (*id)() // initial value of a lazy value",
            ">",
            "struct SegmentTreeLazy {",
            "    public:",
            "    int N;",
            "",
            "    // 0-indexed",
            "    SegmentTreeLazy(int n) {",
            "        t.resize(4*n, e());",
            "        lazy.resize(4*n, id());",
            "        N = n;",
            "    }",
            "",
            "    SegmentTreeLazy(vector<S> &a) {",
            "        t.resize(4*SZ(a));",
            "        lazy.resize(4*SZ(a), id());",
            "        N = SZ(a);",
            "        build(1, 0, N-1, a);",
            "    }",
            "",
            "    S get(int k, int l, int r, int u, int v) {",
            "        lazyUpdate(k, l, r);",
            "        if (l > r || r < u || v < l) return e();",
            "        if (u <= l && r <= v) return t[k];",
            "        int m = (l + r) >> 1;",
            "        S lef = get(k*2, l, m, u, v);",
            "        S rig = get(k*2+1, m+1, r, u, v);",
            "        return op(lef, rig);",
            "    }",
            "",
            "    void lazyUpdate(int k, int l, int r) {",
            "        if (l > r) return;",
            "        if (lazy[k] == id()) return;",
            "        t[k] = mapping(lazy[k], t[k], l, r);",
            "        if (l < r) {",
            "            lazy[k*2] = composition(lazy[k*2], lazy[k]);",
            "            lazy[k*2+1] = composition(lazy[k*2+1], lazy[k]);",
            "        }",
            "        lazy[k] = id();",
            "    }",
            "",
            "    void update(int k, int l, int r, int u, int v, F val) {",
            "        lazyUpdate(k, l, r);",
            "        if (l > r || r < u || v < l) return;",
            "        if (u <= l && r <= v) {",
            "            lazy[k] = val;",
            "            lazyUpdate(k, l, r);",
            "            return;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        update(k*2, l, m, u, v, val);",
            "        update(k*2+1, m+1, r, u, v, val);",
            "        merge(k);",
            "    }",
            "",
            "    void print(int k, int l, int r, int u, int v) {",
            "        lazyUpdate(k, l, r);",
            "        if (l > r || r < u || v < l) return;",
            "        if (l == r) {",
            "            cout << t[k] << ' ';",
            "            return;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        print(k*2, l, m, u, v);",
            "        print(k*2+1, m+1, r, u, v);",
            "    }",
            "",
            "    private:",
            "    vector<S> t;",
            "    vector<F> lazy;",
            "",
            "    void build(int k, int l, int r, vector<S> &a) {",
            "        if (l > r) return;",
            "        if (l == r) {",
            "            t[k] = a[l];",
            "            return;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        build(k*2, l, m, a);",
            "        build(k*2+1, m+1, r, a);",
            "        merge(k);",
            "    }",
            "",
            "    void merge(int k) {",
            "        t[k] = op(t[k*2], t[k*2+1]);",
            "    }",
            "};"
        ],
        "description": "Segment Tree Lazy"
    },
    "Implicit Treap": {
        "prefix": "zzImplicitTreap",
        "body": [
            "mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());",
            "struct Treap {",
            "    struct node {",
            "        int prior, val, sz;",
            "        bool rev;",
            "        node *l, *r;",
            "",
            "        node(int _val = 0) {",
            "            val = _val;",
            "            prior = rnd();",
            "            sz = 1;",
            "            rev = 0;",
            "            l = r = NULL;",
            "        }",
            "    };",
            "    typedef node* pnode;",
            "    pnode root;",
            "",
            "    void clear() {",
            "        root = NULL;",
            "    }",
            "",
            "    Treap() {",
            "        clear();",
            "    }",
            "",
            "    int size(pnode it) {",
            "        return it ? it->sz : 0;",
            "    }",
            "",
            "    void recalc(pnode it) {",
            "        if (it) {",
            "            it->sz = size(it->l) + size(it->r) + 1;",
            "        }",
            "    }",
            "",
            "    void push(pnode it) {",
            "        if (it && it->rev) {",
            "            it->rev = 0;",
            "            swap(it->l, it->r);",
            "            if (it->l) it->l->rev ^= 1;",
            "            if (it->r) it->r->rev ^= 1;",
            "        }",
            "    }",
            "",
            "    void merge(pnode &t, pnode l, pnode r) {",
            "        // largest key of tree l should be smaller than smallest key of tree r",
            "        push(l);",
            "        push(r);",
            "        if (!l || !r) t = l ? l : r;",
            "        else if (l->prior > r->prior) merge(l->r, l->r, r), t = l;",
            "        else merge(r->l, l, r->l), t = r;",
            "        recalc(t);",
            "    }",
            "",
            "    void split(pnode t, pnode &l, pnode &r, int key, int add = 0) {",
            "        if (!t) {",
            "            l = r = NULL;",
            "            return;",
            "        }",
            "        push(t);",
            "        int curKey = add + size(t->l);",
            "        // right tree has keys >= key",
            "        // left tree has keys < key",
            "        if (key <= curKey) split (t->l, l, t->l, key, add), r = t;",
            "        else split (t->r, t->r, r, key, add + 1 + size(t->l)), l = t;",
            "        recalc(t);",
            "    }",
            "",
            "    // reverse all the values from qL to qR",
            "    void reverse(int qL, int qR) {",
            "        assert(0 <= qL && qL <= qR && qR < size(root));",
            "        pnode l, r, mid;",
            " ",
            "        split(root, l, r, qL);",
            "        split(r, mid, r, qR - qL + 1);",
            " ",
            "        mid->rev ^= 1;",
            "        merge(r, mid, r);",
            "        merge(root, l, r);",
            "    }",
            "",
            "    void output(pnode t) {",
            "        if (!t) return;",
            "        push(t);",
            "        output(t->l);",
            "        printf(\"%d \", t->val);",
            "        output(t->r);",
            "    }",
            "",
            "    bool insert(int pos, int val) {",
            "        if (!(0 <= pos && pos <= size(root))) return false;",
            "        if (!root) {",
            "            pnode to_add = new node(val);",
            "            root = to_add;",
            "            return true;",
            "        }",
            " ",
            "        pnode l, r, mid;",
            "        mid = new node(val);",
            " ",
            "        split(root, l, r, pos);",
            "        merge(l, l, mid);",
            "        merge(root, l, r);",
            "        return true;",
            "    }",
            "",
            "    int getVal(pnode &t, int pos, int add = 0) {",
            "        if (!t) return -1;",
            "        push(t);",
            "        int curKey = add + size(t->l);",
            "        if (pos == curKey) return t->val;",
            "        if (pos < curKey) return getVal(t->l, pos, add);",
            "        return getVal(t->r, pos, add + 1 + size(t->l));",
            "    }",
            "",
            "    int getVal(int pos) {",
            "        return getVal(root, pos);",
            "    }",
            "",
            "    int remove(int pos) {",
            "        pnode l, r, mid;",
            "        split(root, l, r, pos);",
            "        split(r, mid, r, 1);",
            "        int res = mid ? mid->val : 0;",
            "        merge(root, l, r);",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Implicit Treap"
    },
    "Ordinary Treap": {
        "prefix": "zzOrdinaryTreap",
        "body": [
            "mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());",
            "struct OrdinaryTreap {",
            "    struct node {",
            "        int key, prior, sz;",
            "        node *l, *r;",
            "",
            "        node(int _key = 0) {",
            "            key = _key;",
            "            prior = rnd();",
            "            sz = 1;",
            "            l = r = NULL;",
            "        }",
            "    };",
            "    typedef node* pnode;",
            "    pnode root;",
            "",
            "    void clear() {",
            "        root = NULL;",
            "    }",
            "",
            "    OrdinaryTreap() {",
            "        clear();",
            "    }",
            "",
            "    int size(pnode it) {",
            "        return it ? it->sz : 0;",
            "    }",
            "",
            "    void recalc(pnode it) {",
            "        if (it) {",
            "            it->sz = size(it->l) + size(it->r) + 1;",
            "        }",
            "    }",
            "",
            "    void merge(pnode &t, pnode l, pnode r) {",
            "        // largest key of tree l should be smaller than smallest key of tree r",
            "        if (!l || !r) t = l ? l : r;",
            "        else if (l->prior > r->prior) merge(l->r, l->r, r), t = l;",
            "        else merge(r->l, l, r->l), t = r;",
            "        recalc(t);",
            "    }",
            "",
            "    void split(pnode t, pnode &l, pnode &r, int key) {",
            "        if (!t) {",
            "            l = r = NULL;",
            "            return;",
            "        }",
            "        // right tree has keys >= key",
            "        // left tree has keys < key",
            "        if (key <= t->key) split(t->l, l, t->l, key), r = t;",
            "        else split(t->r, t->r, r, key), l = t;",
            "        recalc(t);",
            "    }",
            "",
            "    void insert(pnode &t, pnode it) {",
            "        if (!t) t = it;",
            "        else if (it->prior > t->prior) split(t, it->l, it->r, it->key), t = it;",
            "        else insert(it->key < t->key ? t->l : t->r, it);",
            "        recalc(t);",
            "    }",
            "",
            "    void insert(int u) {",
            "        pnode w = new node(u);",
            "        insert(root, w);",
            "    }",
            "",
            "    bool search(pnode &t, int key) {",
            "        if (!t) return false;",
            "        bool co = false;",
            "        if (key == t->key) co = true;",
            "        else if (key < t->key) co |= search(t->l, key);",
            "        else co |= search(t->r, key);",
            "        recalc(t);",
            "        return co;",
            "    }",
            "",
            "    bool search(int key) {",
            "        return search(root, key);",
            "    }",
            "",
            "    void remove(pnode &t, int key) {",
            "        if (!t) return;",
            "        if (key == t->key) merge(t, t->l, t->r);",
            "        else remove(key < t->key ? t->l : t->r, key);",
            "        recalc(t);",
            "    }",
            "",
            "    void remove(int pos) {",
            "        return remove(root, pos);",
            "    }",
            "",
            "    int findPos(pnode &t, int key) {",
            "        if (!t) return -1;",
            "        if (key == t->key) return 1 + size(t->l);",
            "        else if (key > t->key) {",
            "            int e = findPos(t->r, key);",
            "            if (e != -1) return 1 + size(t->l) + e;",
            "            return -1;",
            "        }",
            "        return findPos(t->l, key);",
            "    }",
            "",
            "    int findPos(int val) {",
            "        return findPos(root, val);",
            "    }",
            "",
            "    int getVal(pnode &t, int pos) {",
            "        if (!t) return -1;",
            "",
            "        int e = size(t->l);",
            "        if (e >= pos) return getVal(t->l, pos);",
            "",
            "        pos -= e;",
            "        if (pos == 1) return t->key;",
            "",
            "        pos--;",
            "        return getVal(t->r, pos);",
            "    }",
            "",
            "    int getVal(int pos) {",
            "        if (size(root) < pos) return -1;",
            "        return getVal(root, pos);",
            "    }",
            "};"
        ],
        "description": "Ordinary Treap"
    },
    "Persistent Segment Tree": {
        "prefix": "zzPersistentSegmentTree",
        "body": [
            "struct Vertex {",
            "    Vertex *l, *r;",
            "    ll sum;",
            "",
            "    Vertex(int val) : l(nullptr), r(nullptr), sum(val) {}",
            "    Vertex(Vertex *l, Vertex *r) : l(l), r(r), sum(0) {",
            "        if (l) sum += l->sum;",
            "        if (r) sum += r->sum;",
            "    }",
            "};",
            "",
            "struct PersistentSegmentTree {",
            "    public:",
            "    int N;",
            "    vector <Vertex*> versions;",
            "",
            "    PersistentSegmentTree(int n) {",
            "        N = n;",
            "        vector<int> a(N, 0);",
            "        versions.push_back(build(0, N-1, a));",
            "    }",
            "",
            "    ll get(Vertex* ve, int l, int r, int u, int v) {",
            "        if (l > r || v < l || r < u) return 0;",
            "        if (u <= l && r <= v) return ve->sum;",
            "        int m = (l + r) >> 1;",
            "        return get(ve->l, l, m, u, v) + get(ve->r, m+1, r, u, v);",
            "    }",
            "",
            "    Vertex* update(Vertex *ve, int l, int r, int u, int val) {",
            "        if (l == r) return new Vertex(val);",
            "        int m = (l + r) >> 1;",
            "        if (u <= m) return new Vertex(update(ve->l, l, m, u, val), ve->r);",
            "        return new Vertex(ve->l, update(ve->r, m+1, r, u, val));",
            "    }",
            "",
            "    private:",
            "    Vertex* build(int l, int r, vector<int> &a) {",
            "        if (l == r) return new Vertex(a[l]);",
            "        int m = (l + r) >> 1;",
            "        return new Vertex(build(l, m, a), build(m+1, r, a));",
            "    }",
            "};"
        ],
        "description": "Persistent Segment Tree"
    },
    "Random Number Generator": {
        "prefix": "zzRand",
        "body": [
            "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());"
        ],
        "description": "Random Number Generator"
    },
    "Custom Hash Structure": {
        "prefix": "zzCustomHash",
        "body": [
            "struct custom_hash {",
            "    // unordered_map<long long, int, custom_hash> safe_map;",
            "    static uint64_t splitmix64(uint64_t x) {",
            "        // http://xorshift.di.unimi.it/splitmix64.c",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "",
            "    size_t operator()(uint64_t x) const {",
            "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
            "};"
        ],
        "description": "Custom Hash Structure"
    },
    "Splay Tree": {
        "prefix": "zzSplayTree",
        "body": [
            "// Splay Tree Node",
            "struct Node {",
            "    // define parent node and its 2 children",
            "    Node* parent, *children[2];",
            "    // the size of the subtree with root as this node",
            "    int size;",
            "    // value of the node, Min of the subtree, and label of lazy addition",
            "    ll val, Min, labelAdd;",
            "    // label of lazy reversal",
            "    int labelReverse;",
            "",
            "    // constructor",
            "    Node(int val) {",
            "        parent = children[0] = children[1] = NULL;",
            "        size = 1;",
            "        this->val = val;",
            "        Min = labelAdd = labelReverse = 0;",
            "    }",
            "",
            "    // add v to the subtree",
            "    void add(ll v) {",
            "        // add v to node's value, min and labelAdd",
            "        val += v;",
            "        Min += v;",
            "        labelAdd += v;",
            "    }",
            "",
            "    // apply labels and push them down to children",
            "    void pushDown() {",
            "        if (labelReverse) {",
            "            FOR(i,0,1) {",
            "                if (children[i]) {",
            "                    children[i]->reverse();",
            "                }",
            "            }",
            "            labelReverse = 0;",
            "        }",
            "",
            "        if (labelAdd) {",
            "            FOR(i,0,1) {",
            "                if (children[i]) {",
            "                    children[i]->add(labelAdd);",
            "                }",
            "            }",
            "            labelAdd = 0;",
            "        }",
            "    }",
            "",
            "    // update size of subtree and min of the subtree as well",
            "    void update() {",
            "        size = 1;",
            "        Min = val;",
            "        FOR(i,0,1) {",
            "            if (children[i]) {",
            "                size += children[i]->size;",
            "                ckmin(Min, children[i]->Min);",
            "            }",
            "        }",
            "    }",
            "",
            "    // reverse the whole subtree, first thing is to swap 2 children",
            "    void reverse() {",
            "        swap(children[0], children[1]);",
            "        labelReverse ^= 1;",
            "    }",
            "};",
            "",
            "struct SplayTree {",
            "    Node *root;",
            "",
            "    // create splay tree with 2 dummy nodes (far-left and far-right)",
            "    SplayTree() {",
            "        root = new Node(-1);",
            "        root->children[1] = new Node(-1);",
            "        root->size = 2;",
            "        root->children[1]->parent = root;",
            "    }",
            "",
            "    // since we have 2 dummy nodes, the size should be 2 less than the real size",
            "    int size() { ",
            "        return root->size - 2;",
            "    }",
            "",
            "    // Helper function to rotate node",
            "    void rotate(Node *node) {",
            "        int dirOfNode = (node->parent->children[1] == node);",
            "        Node *parentNode = node->parent;",
            "",
            "        Node *movingChildOfNode = node->children[dirOfNode ^ 1];",
            "",
            "        if (parentNode->parent) {",
            "            parentNode->parent->children[parentNode->parent->children[1] == parentNode] = node;",
            "        }",
            "",
            "        node->parent = parentNode->parent;",
            "        node->children[dirOfNode ^ 1] = parentNode;",
            "",
            "        parentNode->parent = node;",
            "        parentNode->children[dirOfNode] = movingChildOfNode;",
            "",
            "        if (movingChildOfNode) {",
            "            movingChildOfNode->parent = parentNode;",
            "        }",
            "",
            "        parentNode->update();",
            "        node->update();",
            "    }",
            "",
            "    // Splay node so that it is under desiredParent (or to root if desiredParent is null).",
            "    void splay(Node *node, Node *desiredParent = NULL) {",
            "        while (node->parent != desiredParent) {",
            "            Node *parent = node->parent, *parentOfParent = parent->parent;",
            "            if (parentOfParent == desiredParent) {",
            "                rotate(node);",
            "            } else if ((parentOfParent->children[0] == parent) == (parent->children[0] == node)) {",
            "                rotate(parent);",
            "                rotate(node);",
            "            } else {",
            "                rotate(node);",
            "                rotate(node);",
            "            }",
            "        }",
            "        if (!desiredParent) {",
            "            root = node;",
            "        }",
            "    }",
            "",
            "    // Helper function to walk down the tree.",
            "    int walk(Node *node, int &dir, int &pos) {",
            "        node->pushDown();",
            "        int leftSize = node->children[0] ? node->children[0]->size : 0;",
            "        dir = (leftSize < pos);",
            "        if (dir) {",
            "            pos -= leftSize + 1;",
            "        }",
            "        return leftSize;",
            "    }",
            "",
            "    // Insert node n to position pos",
            "    void insert(Node *node, int pos) {",
            "        Node *cur = root;",
            "        int dir;",
            "        // since we have the far-left dummy node and pos starts from 0, increase pos",
            "        pos++;",
            "        while (1) {",
            "            walk(cur, dir, pos);",
            "            if (!cur->children[dir]) {",
            "                break;",
            "            }",
            "            cur = cur->children[dir];",
            "        }",
            "",
            "        cur->children[dir] = node;",
            "        node->parent = cur;",
            "        splay(node);",
            "    }",
            "",
            "    // Find the node at position pos. If sp is true, splay it.",
            "    Node* find(int pos, int sp = true) {",
            "        Node *cur = root;",
            "        int dir;",
            "        // since we have the far-left dummy node and pos starts from 0, increase pos",
            "        pos++;",
            "        while (pos < walk(cur, dir, pos) || dir) {",
            "            cur = cur->children[dir];",
            "        }",
            "        if (sp) splay(cur);",
            "        return cur;",
            "    }",
            "",
            "    // find range [posL, posR)",
            "    // splay node posR to root, then splay posL-1 to below posR, then [posL, posR-1] will be right node of posL-1",
            "    Node *findRange(int posL, int posR) {",
            "        Node *r = find(posR), *l = find(posL - 1, false);",
            "        splay(l, r);",
            "        if (l->children[1]) l->children[1]->pushDown();",
            "        return l->children[1];",
            "    }",
            "",
            "    // find range then disconnect it from the tree",
            "    // remove from position [posL, posR)",
            "    Node* eraseRange(int posL, int posR) {",
            "        Node *range = findRange(posL, posR);",
            "        range->parent->children[1] = NULL;",
            "        range->parent->update();",
            "        range->parent->parent->update();",
            "        range->parent = NULL;",
            "        return range;",
            "    }",
            "",
            "    // recursively print subtree with in-order traversal",
            "    void print(Node *cur, string pref) {",
            "        if (cur == NULL) return;",
            "        cur->pushDown();",
            "        print(cur->children[1], pref + \"  \");",
            "        cout << pref << cur->val << \"\\n\";",
            "        print(cur->children[0], pref + \"  \");",
            "    }",
            "",
            "    // print the whole tree with in-order traversal",
            "    // the tree shown in output will be the same as the real tree if you rotate it 90 degree clockwise",
            "    void printTree() {",
            "        print(root, \"\");",
            "        cout << \"\\n\";",
            "    }",
            "};"
        ],
        "description": "Splay Tree"
    },
    "RMQ": {
        "prefix": "zzRMQ",
        "body": [
            "struct RMQ {",
            "    vector<vi> preComp;",
            "",
            "    int log2_floor(unsigned long long i) {",
            "        return i ? __builtin_clzll(1) - __builtin_clzll(i) : -1;",
            "    }",
            "",
            "    RMQ(vi &a) {",
            "        int n = SZ(a);",
            "        int k = log2_floor(n);",
            "        preComp.resize(k+1, vi(n));",
            "",
            "        FOR(i,0,n-1) {",
            "            preComp[0][i] = a[i];",
            "        }",
            "",
            "        FOR(i,1,k) {",
            "            for (int j = 0; j + (1<<i) - 1 < n; j++) {",
            "                preComp[i][j] = min(preComp[i-1][j], preComp[i-1][j + (1<<(i-1))]);",
            "            }",
            "        }",
            "    }",
            "",
            "    int query(int l, int r) {",
            "        int lg = log2_floor(r - l + 1);",
            "        return min(preComp[lg][l], preComp[lg][r - (1<<lg) + 1]);",
            "    }",
            "};"
        ],
        "description": "RMQ"
    },
    "2D RMQ": {
        "prefix": "zzRMQ2D",
        "body": [
            "struct RMQ2D {",
            "    vector<vector<vector<vi>>> preComp;",
            "",
            "    int log2_floor(unsigned long long i) {",
            "        return i ? __builtin_clzll(1) - __builtin_clzll(i) : -1;",
            "    }",
            "",
            "    RMQ2D(vector<vi> &a) {",
            "        int n = SZ(a);",
            "        int m = SZ(a[0]);",
            "        int kN = log2_floor(n), kM = log2_floor(m);",
            "        preComp.resize(kN+1, vector<vector<vi>>(kM+1, vector<vi>(n, vi(m))));",
            "",
            "        FOR(i,0,n-1) {",
            "            FOR(j,0,m-1) {",
            "                if (a[i][j]) {",
            "                    if (i == 0 && j == 0) preComp[0][0][i][j] = 1;",
            "                    else if (i == 0) preComp[0][0][i][j] = preComp[0][0][i][j-1] + 1;",
            "                    else if (j == 0) preComp[0][0][i][j] = preComp[0][0][i-1][j] + 1;",
            "                    else preComp[0][0][i][j] = min(preComp[0][0][i-1][j], min(preComp[0][0][i][j-1], preComp[0][0][i-1][j-1])) + 1;",
            "                } else {",
            "                    preComp[0][0][i][j] = 0;",
            "                }",
            "            }",
            "        }",
            "",
            "        FOR(i,0,kN) {",
            "            FOR(j,0,kM) {",
            "                if (i + j == 0) continue;",
            "                for (int x = 0; x + (1<<i) - 1 < n; x++) {",
            "                    for (int y = 0; y + (1<<j) - 1 < m; y++) {",
            "                        if (j == 0) {",
            "                            preComp[i][j][x][y] = max(preComp[i-1][j][x][y], preComp[i-1][j][x + (1<<(i-1))][y]);",
            "                        } else {",
            "                            preComp[i][j][x][y] = max(preComp[i][j-1][x][y], preComp[i][j-1][x][y + (1<<(j-1))]);",
            "                        }",
            "                    }",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    int query(int x, int y, int u, int v) {",
            "        int lgX = log2_floor(u - x + 1), lgY = log2_floor(v - y + 1);",
            "        return max(",
            "            max(preComp[lgX][lgY][x][y], preComp[lgX][lgY][x][v - (1<<lgY) + 1]),",
            "            max(preComp[lgX][lgY][u - (1<<lgX) + 1][y], preComp[lgX][lgY][u - (1<<lgX) + 1][v - (1<<lgY) + 1])",
            "        );",
            "    }",
            "};"
        ],
        "description": "2D RMQ"
    },
    "Disjoint Sparse Table": {
        "prefix": "zzDisjointSparseTable",
        "body": [
            "struct DisjointSparseTable {",
            "    vi a;",
            "    int size, x;",
            "    ll p;",
            "    vector<vi> table;",
            "",
            "    DisjointSparseTable(vi &a, int p) {",
            "        // all 0-indexed",
            "        this->a = a;",
            "        this->p = p;",
            "",
            "        // size = 2^x = 2^floor(log_2(n))",
            "        size = SZ(a);",
            "        x = __builtin_clz(SZ(a)) ^ 31;",
            "        if( (1<<x) != SZ(a)) size = (1<<(++x));",
            "        this->a.resize(size);",
            "",
            "        table.resize(x+1, vi(size));",
            "        ",
            "        build();",
            "    }",
            "",
            "    void build() {",
            "        int len = 1;",
            "        FORE(level,x,0) {",
            "            for (int l = 0; l < size; l += len) {",
            "                // [l, r)",
            "                int r = l + len;",
            "                int mid = (l + r) >> 1;",
            "                table[level][mid] = a[mid] % p;",
            "                FORE(i,mid-1,l) table[level][i] = (ll) table[level][i+1] * a[i] % p;",
            "",
            "                if (mid + 1 < r) {",
            "                    table[level][mid+1] = a[mid+1] % p;",
            "                    FOR(i,mid+2,r-1) table[level][i] = (ll) table[level][i-1] * a[i] % p;",
            "                }",
            "            }",
            "            len <<= 1;",
            "        }",
            "    }",
            "",
            "    int query(int l, int r) {",
            "        // [l, r]",
            "        if (l == r) {",
            "            return a[l] % p;",
            "        }",
            "",
            "        int k2 = __builtin_clz(l ^ r) ^ 31;",
            "        int lev = x - 1 - k2;",
            "        int ans = table[lev][l];",
            "        if (r & ((1<<k2) - 1)) {",
            "            // y % (1<<k2)",
            "            ans = (ll) ans * table[lev][r] % p;",
            "        }",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Disjoint Sparse Table"
    },
    "Vector Basis": {
        "prefix": "zzVectorBasis",
        "body": [
            "struct VectorBasis {",
            "    vi basis;",
            "    int d, sz;",
            "    int numVectors;",
            "",
            "    VectorBasis(int d) {",
            "        this->d = d;",
            "        this->sz = 0;",
            "",
            "        // numVectors is the number of vectors inserted",
            "        this->numVectors = 0;",
            "        basis.resize(d);",
            "        FOR(i,0,d-1) basis[i] = 0;",
            "    }",
            "",
            "    void insertVector(int mask, bool incCnt = true) {",
            "        // insert mask to the basis",
            "        if (incCnt) numVectors++;",
            "        FOR(i,0,d-1) {",
            "            if (!(mask & (1 << i))) continue;",
            "",
            "            if (!basis[i]) {",
            "                basis[i] = mask;",
            "                sz++;",
            "                return;",
            "            }",
            "",
            "            mask ^= basis[i];",
            "        }",
            "    }",
            "",
            "    bool checkXor(int mask) {",
            "        // check if mask is representable by the basis",
            "        FOR(i,0,d-1) {",
            "            if (!(mask & (1<<i))) continue;",
            "            if (!basis[i]) return false;",
            "            mask ^= basis[i];",
            "        }",
            "        return true;",
            "    }",
            "",
            "    void merge(VectorBasis &v) {",
            "        // merge 2 basis with the same dimention",
            "        numVectors += v.numVectors;",
            "        FOR(i,0,d-1) {",
            "            if (v.basis[i]) {",
            "                insertVector(v.basis[i], false);",
            "            }",
            "        }",
            "    }",
            "};"
        ],
        "description": "Vector Basis"
    },
    "Sqrt Tree": {
        "prefix": "zzSqrtTree",
        "body": [
            "struct SqrtTreeItem {",
            "    // fill in the item as your preference",
            "};",
            "",
            "// fill in the operation",
            "SqrtTreeItem op(const SqrtTreeItem &a, const SqrtTreeItem &b);",
            "",
            "inline int log2Up(int n) {",
            "    int res = 0;",
            "    while ((1 << res) < n) {",
            "        res++;",
            "    }",
            "    return res;",
            "}",
            "",
            "struct SqrtTree {",
            "    int n, lg, indexSz;",
            "    vector<SqrtTreeItem> v;",
            "    vi clz, layers, onLayer;",
            "    vector<vector<SqrtTreeItem>> pref, suf, between;",
            "",
            "    inline void buildBlock(int layer, int l, int r) {",
            "        // block [l, r)",
            "        // calculate prefix and suffix arrays",
            "        pref[layer][l] = v[l];",
            "        FOR(i,l+1,r-1) {",
            "            pref[layer][i] = op(pref[layer][i-1], v[i]);",
            "        }",
            "        suf[layer][r-1] = v[r-1];",
            "        FORE(i,r-2,l) {",
            "            suf[layer][i] = op(v[i], suf[layer][i+1]);",
            "        }",
            "    }",
            "",
            "    inline void buildBetween(int layer, int lBound, int rBound, int betweenOffs) {",
            "        // log of block size",
            "        int bSzLog = (layers[layer]+1) >> 1;",
            "        // log of number of blocks",
            "        int bCntLog = layers[layer] >> 1;",
            "        // block size",
            "        int bSz = 1 << bSzLog;",
            "        // number of blocks, it's basically ceilDiv(r - l, bSz)",
            "        int bCnt = (rBound - lBound + bSz - 1) >> bSzLog;",
            "",
            "        // fill in \"between\"",
            "        for (int i = 0; i < bCnt; i++) {",
            "            SqrtTreeItem ans;",
            "            for (int j = i; j < bCnt; j++) {",
            "                SqrtTreeItem add = suf[layer][lBound + (j << bSzLog)];",
            "                ans = (i == j) ? add : op(ans, add);",
            "                // between[i][j]",
            "                between[layer-1][betweenOffs + lBound + (i << bCntLog) + j] = ans;",
            "            }",
            "        }",
            "    }",
            "",
            "    inline void buildBetweenZero() {",
            "        int bSzLog = (lg+1) >> 1;",
            "        // put values of blocks to the \"index\" sqrt tree and build it",
            "        for (int i = 0; i < indexSz; i++) {",
            "            v[n+i] = suf[0][i << bSzLog];",
            "        }",
            "        build(1, n, n + indexSz, (1 << lg) - n);",
            "    }",
            "",
            "    inline void updateBetweenZero(int bid) {",
            "        int bSzLog = (lg+1) >> 1;",
            "        // update block value of \"index\" sqrt tree",
            "        v[n+bid] = suf[0][bid << bSzLog];",
            "        // update the \"index\" sqrt tree",
            "        update(1, n, n + indexSz, (1 << lg) - n, n+bid);",
            "    }",
            "",
            "    void build(int layer, int lBound, int rBound, int betweenOffset) {",
            "        if (layer >= SZ(layers)) {",
            "            // return if layer index is larger than the number of layers",
            "            return;",
            "        }",
            "",
            "        // block size",
            "        int bSz = 1 << ((layers[layer]+1) >> 1);",
            "        for (int l = lBound; l < rBound; l += bSz) {",
            "            int r = min(l + bSz, rBound);",
            "            buildBlock(layer, l, r);",
            "            build(layer+1, l, r, betweenOffset);",
            "        }",
            "",
            "        // build \"index\" sqrt tree on layer 0, otherwise build \"between\"",
            "        if (layer == 0) {",
            "            buildBetweenZero();",
            "        } else {",
            "            buildBetween(layer, lBound, rBound, betweenOffset);",
            "        }",
            "    }",
            "",
            "    void update(int layer, int lBound, int rBound, int betweenOffset, int x) {",
            "        if (layer >= (int)layers.size()) {",
            "            // return if layer index is larger than the number of layers",
            "            return;",
            "        }",
            "",
            "        // log of block size",
            "        int bSzLog = (layers[layer]+1) >> 1;",
            "        // block size",
            "        int bSz = 1 << bSzLog;",
            "        // block index containing x",
            "        int blockIdx = (x - lBound) >> bSzLog;",
            "        // [l, r) of the block containing x",
            "        int l = lBound + (blockIdx << bSzLog);",
            "        int r = min(l + bSz, rBound);",
            "        // update the pref and suf",
            "        buildBlock(layer, l, r);",
            "",
            "        // update \"index\" sqrt tree on layer 0, otherwise update \"between\"",
            "        if (layer == 0) {",
            "            updateBetweenZero(blockIdx);",
            "        } else {",
            "            buildBetween(layer, lBound, rBound, betweenOffset);",
            "        }",
            "        // update till the leaf",
            "        update(layer+1, l, r, betweenOffset, x);",
            "    }",
            "",
            "    inline SqrtTreeItem query(int l, int r, int betweenOffset, int base) {",
            "        // segment [l, r]",
            "        // length 1",
            "        if (l == r) {",
            "            return v[l];",
            "        }",
            "        // length 2",
            "        if (l + 1 == r) {",
            "            return op(v[l], v[r]);",
            "        }",
            "",
            "        // find the layer number which covers [l, r]",
            "        int layer = onLayer[clz[(l - base) ^ (r - base)]];",
            "        // block size of blocks on this layer",
            "        int bSzLog = (layers[layer]+1) >> 1;",
            "        // number of blocks on this layer",
            "        int bCntLog = layers[layer] >> 1;",
            "        // lBound = number of elements in the blocks before block containing l",
            "        int lBound = (((l - base) >> layers[layer]) << layers[layer]) + base;",
            "        // lBlock and rBlock are the most left and right blocks that are lying inside the query",
            "        // not counting the left most or right most in the case they satisfy the above condition",
            "        int lBlock = ((l - lBound) >> bSzLog) + 1;",
            "        int rBlock = ((r - lBound) >> bSzLog) - 1;",
            "",
            "        // get answer of the left most block",
            "        SqrtTreeItem ans = suf[layer][l];",
            "        if (lBlock <= rBlock) {",
            "            SqrtTreeItem add = (layer == 0) ? (",
            "                // if it's on the root of the tree, we query using \"index\", which stored",
            "                // all blocks of the first layer already",
            "                query(n + lBlock, n + rBlock, (1 << lg) - n, n)",
            "            ) : (",
            "                // if layer is not on the root of the tree, we easily use \"between\" to get the result",
            "                between[layer-1][betweenOffset + lBound + (lBlock << bCntLog) + rBlock]",
            "            );",
            "            // add the block to the answer",
            "            ans = op(ans, add);",
            "        }",
            "        // get answer of the right most block",
            "        ans = op(ans, pref[layer][r]);",
            "        return ans;",
            "    }",
            "",
            "    inline SqrtTreeItem query(int l, int r) {",
            "        return query(l, r, 0, 0);",
            "    }",
            "",
            "    inline void update(int x, const SqrtTreeItem &item) {",
            "        v[x] = item;",
            "        update(0, 0, n, 0, x);",
            "    }",
            "",
            "    SqrtTree(const vector<SqrtTreeItem> &a) : n(SZ(a)), lg(log2Up(n)), v(a), clz(1 << lg), onLayer(lg+1) {",
            "        // n = size of the initial array",
            "        // lg = ceil(log2(n))",
            "",
            "        // clz[i] = lowest set bit",
            "        clz[0] = 0;",
            "        FOR(i,1,SZ(clz)-1) clz[i] = clz[i >> 1] + 1;",
            "",
            "        // layers[i] is the block length on layer i",
            "        // onLayer[i] = x means that if the block length is 2^i, it should be on layer x",
            "        int tlg = lg;",
            "        while (tlg > 1) {",
            "            onLayer[tlg] = SZ(layers);",
            "            layers.push_back(tlg);",
            "            // sqrt(2^x) = 2^(x / 2)",
            "            tlg = (tlg + 1) >> 1;",
            "        }",
            "        FORE(i,lg-1,0) ckmax(onLayer[i], onLayer[i+1]);",
            "",
            "        int betweenLayers = max(0, SZ(layers) - 1);",
            "        int bSzLog = (lg + 1) >> 1;",
            "        int bSz = (1 << bSzLog);",
            "        // indexSz is number of bSz-length blocks separating n",
            "        // it's basically ceilDiv(n, bSz)",
            "        indexSz = (n + bSz - 1) >> bSzLog;",
            "",
            "        v.resize(n + indexSz);",
            "        pref.assign(layers.size(), vector<SqrtTreeItem>(n + indexSz));",
            "        suf.assign(layers.size(), vector<SqrtTreeItem>(n + indexSz));",
            "        between.assign(betweenLayers, vector<SqrtTreeItem>((1 << lg) + bSz));",
            "",
            "        build(0, 0, n, 0);",
            "    }",
            "};",
            ""
        ],
        "description": "Sqrt Tree"
    },
    "Suffix Array": {
        "prefix": "zzSuffixArray",
        "body": [
            "struct SuffixArray {",
            "    int n;",
            "    vi SA, RA, tempRA, tempSA, c, LCP, PLCP, behind;",
            "    string str;",
            "    vector<vi> Min;",
            "",
            "    SuffixArray(string &s) {",
            "        n = SZ(s);",
            "        str = s;",
            "        SA.resize(n, 0);",
            "        RA.resize(n, 0);",
            "        tempRA.resize(n, 0);",
            "        tempSA.resize(n, 0);",
            "        c.resize(max(300, n), 0);",
            "        LCP.resize(n, 0);",
            "        PLCP.resize(n, 0);",
            "        behind.resize(n, 0);",
            "        Min.resize(n, vi(int(log2(n))+1, 0));",
            "        build();",
            "        buildLCP();",
            "        buildRMQ();",
            "    }",
            "",
            "    void countingSort(int k) {",
            "        int sum = 0, maxi = max(300, n);",
            "        FOR(i,0,maxi-1) c[i] = 0;",
            "        FOR(i,0,n-1)",
            "            if (i+k < n) c[RA[i+k]]++;",
            "            else c[0]++;",
            "        FOR(i,0,maxi-1) {",
            "            int t = c[i];",
            "            c[i] = sum;",
            "            sum += t;",
            "        }",
            "        FOR(i,0,n-1) {",
            "            int a = 0;",
            "            if (SA[i]+k < n) a = RA[SA[i]+k];",
            "            tempSA[c[a]++] = SA[i];",
            "        }",
            "        FOR(i,0,n-1) SA[i] = tempSA[i];",
            "    }",
            "",
            "    void build() {",
            "        int r;",
            "        FOR(i,0,n-1) SA[i] = i;",
            "        FOR(i,0,n-1) RA[i] = str[i];",
            "        for (int k = 1; k < n; k <<= 1) {",
            "            countingSort(k);",
            "            countingSort(0);",
            "            tempRA[SA[0]] = r = 0;",
            "            FOR(i,1,n-1) {",
            "                if (RA[SA[i]] != RA[SA[i-1]]) {",
            "                    tempRA[SA[i]] = ++r;",
            "                    continue;",
            "                }",
            "                int a, b;",
            "                if (SA[i]+k >= n) a = 0;",
            "                else a = RA[SA[i]+k];",
            "                if (SA[i-1]+k >= n) b = 0;",
            "                else b = RA[SA[i-1]+k];",
            "                if (a == b) tempRA[SA[i]] = r;",
            "                else tempRA[SA[i]] = ++r;",
            "            }",
            "            FOR(i,0,n-1) RA[i] = tempRA[i];",
            "            if (r == n-1) break;",
            "        }",
            "    }",
            "",
            "    void buildLCP() {",
            "        behind[SA[0]] = -1;",
            "        FOR(i,1,n-1) behind[SA[i]] = SA[i-1];",
            "        int L = 0;",
            "        FOR(i,0,n-1) {",
            "            if (behind[i] == -1) {",
            "                PLCP[i] = 0;",
            "                continue; ",
            "            }",
            "            while (str[i+L] == str[behind[i]+L]) L++;",
            "            PLCP[i] = L;",
            "            L = max(L-1,0);",
            "        }",
            "        FOR(i,0,n-1) LCP[i] = PLCP[SA[i]];",
            "    }",
            "",
            "    void print() {",
            "        FOR(i,0,n-1) cout << SA[i] << ' ' << str.substr(SA[i]) << ' ' << LCP[i] << \"\\n\";",
            "    }",
            "",
            "    void buildRMQ() {",
            "        FOR(i,0,n-1) Min[i][0] = LCP[i];",
            "        ",
            "        for (int k = 1; (1<<k) <= n; k++)",
            "            for (int i = 0; i + (1<<k) - 1 < n; i++) {",
            "                Min[i][k] = min(Min[i][k-1], Min[i+(1<<(k-1))][k-1]);",
            "            }",
            "    }",
            "",
            "    int getLCP(int u, int v) {",
            "        if (u == v) return n - u;",
            "        u = RA[u];",
            "        v = RA[v];",
            "        if (u > v) swap(u, v);",
            "",
            "        int l = u+1, r = v;",
            "        int k = log2(r-l+1);",
            "",
            "        return min(Min[l][k], Min[r-(1<<k)+1][k]);",
            "    }",
            "};"
        ],
        "description": "Suffix Array"
    }
}
