{
    "CP Starter": {
        "prefix": "zzCPStarter",
        "body": [
            "/*",
            "    Author: Nguyen Tan Bao",
            "    Status:",
            "    Idea:",
            "*/",
            "",
            "#include <bits/stdc++.h>",
            "#define FI first",
            "#define SE second",
            "#define EPS 1e-9",
            "#define ALL(a) a.begin(),a.end()",
            "#define SZ(a) int((a).size())",
            "#define MS(s, n) memset(s, n, sizeof(s))",
            "#define FOR(i,a,b) for (int i = (a); i <= (b); i++)",
            "#define FORE(i,a,b) for (int i = (a); i >= (b); i--)",
            "#define FORALL(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)",
            "//__builtin_ffs(x) return 1 + index of least significant 1-bit of x",
            "//__builtin_clz(x) return number of leading zeros of x",
            "//__builtin_ctz(x) return number of trailing zeros of x",
            "",
            "using namespace std;",
            "using ll = long long;",
            "using ld = double;",
            "typedef pair<int, int> II;",
            "typedef pair<II, int> III;",
            "typedef complex<ld> cd;",
            "typedef vector<cd> vcd;",
            "",
            "const ll MODBASE = 1000000007LL;",
            "const int MAXN = 110;",
            "const int MAXM = 1000;",
            "const int MAXK = 16;",
            "const int MAXQ = 200010;",
            "",
            "int main() {",
            "    ios::sync_with_stdio(0);",
            "    cin.tie(nullptr);",
            "    return 0;",
            "}",
            ""
        ],
        "description": "CP Starter"
    },
    "GCD Function": {
        "prefix": "zzGCDFunction",
        "body": [
            "int gcd(int a, int b) {",
            "    while (b) {",
            "        a %= b;",
            "        swap(a, b);",
            "    }",
            "    return a;",
            "}"
        ],
        "description": "GCD Function"
    },
    "Sieve of Eratosthenes": {
        "prefix": "zzSieveBase",
        "body": [
            "void sieveBase(int n) {",
            "    FOR(i,2,n) {",
            "        if (nt[i] == 0) {",
            "            nt[i] = i;",
            "            for (ll j = (ll) i * i; j <= n; j += i) nt[j] = i;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Sieve of Eratosthenes"
    },
    "Binary Exponentiation": {
        "prefix": "zzBinPowMod",
        "body": [
          "ll binPowMod(ll a, ll b) {",
          "    a %= MOD;",
          "    ll res = 1;",
          "    while (b > 0) {",
          "        if (b & 1LL) res = res * a % MOD;",
          "        a = a * a % MOD;",
          "        b >>= 1LL;",
          "    }",
          "    return res;",
          "}",
          "",
          "ll add(ll a, ll b) {",
          "    return (a + b) % MOD;",
          "}",
          "",
          "ll sub(ll a, ll b) {",
          "    return (a - b + MOD) % MOD;",
          "}",
          "",
          "ll mul(ll a, ll b) {",
          "    return a * b % MOD;",
          "}"
        ],
        "description": "Binary Exponentiation"
    },
    "Extended Euclid Algorithm": {
        "prefix": "zzExtendedEuclid",
        "body": [
            "int extendedEuclid(int a, int b, int &x, int &y) {",
            "    if (b == 0) {",
            "        x = 1;",
            "        y = 0;",
            "        return a;",
            "    }",
            "    int X1, Y1;",
            "    int d = extendedEuclid(b, a % b, X1, Y1);",
            "    x = Y1;",
            "    y = X1 - Y1 * (a / b);",
            "    return d;",
            "}"
        ],
        "description": "Extended Euclid Algorithm"
    },
    "Disjoint Set Union": {
        "prefix": "zzDSU",
        "body": [
            "struct DisjointSetUnion {",
            "  public:",
            "    // creates an undirected graph with n vertices and 0 edges.",
            "    DisjointSetUnion() : _n(0) {}",
            "    DisjointSetUnion(int n) : _n(n), parent_or_size(n, -1) {}",
            "",
            "    // add an edge (u, v)",
            "    // If the vertices u and v were in the same connected component, ",
            "    // it returns the representative of this connected component. ",
            "    // Otherwise, it returns the representative of the new connected component.",
            "    int merge(int u, int v) {",
            "        assert(0 <= u && u < _n);",
            "        assert(0 <= v && v < _n);",
            "        int x = leader(u), y = leader(v);",
            "        if (x == y) return x;",
            "        if (-parent_or_size[x] < -parent_or_size[y]) swap(x, y);",
            "        parent_or_size[x] += parent_or_size[y];",
            "        parent_or_size[y] = x;",
            "        return x;",
            "    }",
            "",
            "    // It returns whether the vertices u and v are in the same connected component",
            "    bool same(int u, int v) {",
            "        assert(0 <= u && u < _n);",
            "        assert(0 <= v && v < _n);",
            "        return leader(u) == leader(v);",
            "    }",
            "",
            "    // It returns the representative of the connected component that contains the vertex u",
            "    int leader(int u) {",
            "        assert(0 <= u && u < _n);",
            "        if (parent_or_size[u] < 0) return u;",
            "        return parent_or_size[u] = leader(parent_or_size[u]);",
            "    }",
            "",
            "    // It returns the size of the connected component that contains the vertex u",
            "    int size(int u) {",
            "        assert(0 <= u && u < _n);",
            "        return -parent_or_size[leader(u)];",
            "    }",
            "",
            "    // It divides the graph into connected components and returns the list of them",
            "    vector<vector<int>> groups() {",
            "        vector<int> leader_buf(_n), group_size(_n);",
            "        FOR(i,0,_n-1) {",
            "            leader_buf[i] = leader(i);",
            "            group_size[leader_buf[i]]++;",
            "        }",
            "        vector<vector<int>> result(_n);",
            "        FOR(i,0,_n-1) result[i].reserve(group_size[i]);",
            "        FOR(i,0,_n-1) result[leader_buf[i]].push_back(i);",
            "        result.erase(",
            "            std::remove_if(result.begin(), result.end(),",
            "                           [&](const std::vector<int>& v) { return v.empty(); }),",
            "            result.end());",
            "        return result;",
            "    }",
            "",
            "  private:",
            "    int _n;",
            "    vector<int> parent_or_size;",
            "};"
        ],
        "description": "Disjoint Set Union"
    }
}